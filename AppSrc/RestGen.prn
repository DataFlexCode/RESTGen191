Compiling Program: C:\Projects\RESTGen191\AppSrc\RestGen.src
Memory Available: 1461743616
1>Use DFAllEnt.pkg
Using pre-compiled package DFALLENT.PKG
Including file: dfallent.pkd    (C:\Program Files (x86)\DataFlex 19.1\Pkg\dfallent.pkd)
67438>Use cCJStandardCommandBarSystem.pkg
Including file: cCJStandardCommandBarSystem.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCJStandardCommandBarSystem.pkg)
67438>>>// these are all the packages used in a standard MDI menubar/toolbar system
67438>>>
67438>>>Use cCJCommandBarSystem.pkg
67438>>>Use cCJStandardMenuItemClasses.pkg
Including file: cCJStandardMenuItemClasses.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCJStandardMenuItemClasses.pkg)
67438>>>>>Use Dfpanel.pkg
67438>>>>>Use cCJCommandBarSystem.pkg
67438>>>>>Use LanguageText.pkg
67438>>>>>
67438>>>>>
67438>>>>>Class cCJUndoMenuItem is a cCJMenuItem
67439>>>>>    
67439>>>>>    Procedure Construct_Object
67441>>>>>        Forward Send Construct_Object
67443>>>>>        Set psCaption   to C_$CaptionUndo
67444>>>>>        Set psToolTip to C_$ToolTipUndo
67445>>>>>        Set psDescription to C_$DescUndo
67446>>>>>        Set psImage to "ActionUndo.ico"
67447>>>>>        Set pbActiveUpdate to True
67448>>>>>        Set psCategory to C_$CategoryEdit
67449>>>>>        Set psShortcut to C_$Key_Ctrl_Z
67450>>>>>    End_Procedure
67451>>>>>    
67451>>>>>    Procedure OnExecute Variant vCommandBarControl
67453>>>>>        Send Undo of (focus(Self))
67454>>>>>    End_Procedure
67455>>>>>    
67455>>>>>    Function IsEnabled Returns Boolean
67457>>>>>        Boolean bEnabled
67457>>>>>        Get CanUndo of (Focus(Self)) to bEnabled
67458>>>>>        Function_Return bEnabled
67459>>>>>    End_Function
67460>>>>>    
67460>>>>>End_Class
67461>>>>>
67461>>>>>
67461>>>>>Class cCJDeleteEditMenuItem is a cCJMenuItem
67462>>>>>    
67462>>>>>    Procedure Construct_Object
67464>>>>>        Forward Send Construct_Object
67466>>>>>        Set psCaption   to C_$CaptionDelete
67467>>>>>        Set psToolTip to C_$ToolTipDelete
67468>>>>>        Set psDescription to C_$DescDelete
67469>>>>>        Set psImage to "actionDelete.ico"
67470>>>>>        Set psShortcut to C_$Key_Delete
67471>>>>>        Set pbActiveUpdate to True
67472>>>>>        Set psCategory to C_$CategoryEdit
67473>>>>>    End_Procedure
67474>>>>>    
67474>>>>>    
67474>>>>>    Procedure OnExecute Variant vCommandBarControl
67476>>>>>        Send Delete of (focus(Self))
67477>>>>>    End_Procedure
67478>>>>>    
67478>>>>>    Function IsEnabled Returns Boolean
67480>>>>>        Boolean bEnabled
67480>>>>>        Get CanDelete of (Focus(Self)) to bEnabled
67481>>>>>        Function_Return bEnabled
67482>>>>>    End_Function
67483>>>>>    
67483>>>>>End_Class
67484>>>>>
67484>>>>>
67484>>>>>Class cCJCutMenuItem is a cCJMenuItem
67485>>>>>    
67485>>>>>    Procedure Construct_Object
67487>>>>>        Forward Send Construct_Object
67489>>>>>        Set psCaption   to C_$CaptionCut
67490>>>>>        Set psToolTip to C_$TooltipCut
67491>>>>>        Set psDescription to C_$DescCut
67492>>>>>        Set psImage to "actionCut.ico"
67493>>>>>        Set psShortcut to C_$Key_Ctrl_X
67494>>>>>        Set pbActiveUpdate to True
67495>>>>>        Set psCategory to C_$CategoryEdit
67496>>>>>    End_Procedure
67497>>>>>    
67497>>>>>    
67497>>>>>    Procedure OnExecute Variant vCommandBarControl
67499>>>>>        Send Cut of (focus(Self))
67500>>>>>    End_Procedure
67501>>>>>    
67501>>>>>    Function IsEnabled Returns Boolean
67503>>>>>        Boolean bEnabled
67503>>>>>        Get CanCut of (Focus(Self)) to bEnabled
67504>>>>>        Function_Return bEnabled
67505>>>>>    End_Function
67506>>>>>    
67506>>>>>End_Class
67507>>>>>
67507>>>>>
67507>>>>>Class cCJCopyMenuItem is a cCJMenuItem
67508>>>>>    
67508>>>>>    Procedure Construct_Object
67510>>>>>        Forward Send Construct_Object
67512>>>>>        Set psCaption   to C_$CaptionCopy
67513>>>>>        Set psToolTip to C_$ToolTipCopy
67514>>>>>        Set psDescription to C_$DescCopy
67515>>>>>        Set psImage to "actionCopy.ico"
67516>>>>>        Set psShortcut to C_$Key_Ctrl_C
67517>>>>>        Set pbActiveUpdate to True
67518>>>>>        Set psCategory to C_$CategoryEdit
67519>>>>>    End_Procedure
67520>>>>>    
67520>>>>>    
67520>>>>>    Procedure OnExecute Variant vCommandBarControl
67522>>>>>        Send Copy of (focus(Self))
67523>>>>>    End_Procedure
67524>>>>>    
67524>>>>>    Function IsEnabled Returns Boolean
67526>>>>>        Boolean bEnabled
67526>>>>>        Get CanCopy of (Focus(Self)) to bEnabled
67527>>>>>        Function_Return bEnabled
67528>>>>>    End_Function
67529>>>>>    
67529>>>>>End_Class
67530>>>>>
67530>>>>>
67530>>>>>Class cCJPasteMenuItem is a cCJMenuItem
67531>>>>>    
67531>>>>>    Procedure Construct_Object
67533>>>>>        Forward Send Construct_Object
67535>>>>>        Set psCaption   to C_$CaptionPaste
67536>>>>>        Set psToolTip to C_$ToolTipPaste
67537>>>>>        Set psDescription to C_$DescPaste
67538>>>>>        Set psImage to "actionPaste.ico"
67539>>>>>        Set pbActiveUpdate to True
67540>>>>>        Set psShortcut to C_$Key_Ctrl_V
67541>>>>>        Set psCategory to C_$CategoryEdit
67542>>>>>    End_Procedure
67543>>>>>    
67543>>>>>    
67543>>>>>    Procedure OnExecute Variant vCommandBarControl
67545>>>>>        Send Paste of (focus(Self))
67546>>>>>    End_Procedure
67547>>>>>    
67547>>>>>    Function IsEnabled Returns Boolean
67549>>>>>        Boolean bEnabled
67549>>>>>        Get CanPaste of (Focus(Self)) to bEnabled
67550>>>>>        Function_Return bEnabled
67551>>>>>    End_Function
67552>>>>>    
67552>>>>>End_Class
67553>>>>>
67553>>>>>Class cCJSelectAllMenuItem is a cCJMenuItem
67554>>>>>    
67554>>>>>    Procedure Construct_Object
67556>>>>>        Forward Send Construct_Object
67558>>>>>        Set psCaption   to C_$CaptionSelectAll
67559>>>>>        Set psToolTip to C_$ToolTipSelectAll
67560>>>>>        Set psDescription to C_$DescSelectAll
67561>>>>>        Set pbActiveUpdate to True
67562>>>>>        Set psShortcut to C_$Key_Ctrl_A
67563>>>>>        Set psCategory to C_$CategoryEdit
67564>>>>>    End_Procedure
67565>>>>>    
67565>>>>>    
67565>>>>>    Procedure OnExecute Variant vCommandBarControl
67567>>>>>        Send Select_All of (focus(Self))
67568>>>>>    End_Procedure
67569>>>>>    
67569>>>>>    Function IsEnabled Returns Boolean
67571>>>>>        Boolean bEnabled
67571>>>>>        Get CanSelect of (Focus(Self)) to bEnabled
67572>>>>>        Function_Return bEnabled
67573>>>>>    End_Function
67574>>>>>    
67574>>>>>End_Class
67575>>>>>
67575>>>>>
67575>>>>>Class cCJExitMenuItem is a cCJMenuItem
67576>>>>>    
67576>>>>>    Procedure Construct_Object
67578>>>>>        Forward Send Construct_Object
67580>>>>>        Set psCaption to C_$CaptionExit
67581>>>>>        Set psToolTip to C_$ToolTipExit
67582>>>>>        Set psDescription to C_$ToolTipExit
67583>>>>>        Set psShortcut to C_$Key_Alt_F4
67584>>>>>        Set psCategory to C_$CategoryFile
67585>>>>>    End_Procedure
67586>>>>>    
67586>>>>>    Procedure OnExecute Variant vCommandBarControl
67588>>>>>        Send Exit_Application of Desktop
67589>>>>>    End_Procedure
67590>>>>>    
67590>>>>>End_Class
67591>>>>>
67591>>>>>Class cCJHelpMenuItem is a cCJMenuItem
67592>>>>>    
67592>>>>>    Procedure Construct_Object
67594>>>>>        Forward Send Construct_Object
67596>>>>>        Set psCaption to C_$CaptionHelp
67597>>>>>        Set psDescription to C_$ToolTipHelp
67598>>>>>        Set psToolTip to C_$DescHelp
67599>>>>>        Set psImage to "ActionHelp.ico"
67600>>>>>        Set psShortcut to "F1"
67601>>>>>        Set psCategory to C_$CategoryHelp
67602>>>>>    End_Procedure
67603>>>>>    
67603>>>>>    Procedure OnExecute Variant vCommandBarControl
67605>>>>>        Send Help of (Focus(Self))
67606>>>>>    End_Procedure
67607>>>>>    
67607>>>>>End_Class
67608>>>>>
67608>>>>>Class cCJStatusbarMenuItem is a cCJMenuItem
67609>>>>>    
67609>>>>>    Procedure Construct_Object
67611>>>>>        Forward Send Construct_Object
67613>>>>>        Set psCaption to C_$CaptionAddStatusbar
67614>>>>>        Set psToolTip to C_$ToolTipAddStatusbar
67615>>>>>        Set psDescription to  C_$DescAddStatusbar
67616>>>>>        Set psCategory to C_$CategoryWindow
67617>>>>>    End_Procedure
67618>>>>>    
67618>>>>>    Procedure OnExecute Variant vCommandBarControl
67620>>>>>        Handle hoCommandBars hoClientArea
67620>>>>>        Get CommandBarSystemObject to hoCommandBars
67621>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67622>>>>>        If hoClientArea Begin
67624>>>>>            // the clientarea's parent panel has message
67624>>>>>            Send Toggle_StatusBar of (Parent(hoClientArea))
67625>>>>>        End
67625>>>>>>
67625>>>>>    End_Procedure
67626>>>>>    
67626>>>>>    Function IsChecked Returns Boolean
67628>>>>>        Boolean bOn
67628>>>>>        Handle hoCommandBars hoClientArea
67628>>>>>        Get CommandBarSystemObject to hoCommandBars
67629>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67630>>>>>        If hoClientArea Begin
67632>>>>>            // the clientarea's parent panel has message
67632>>>>>            Get StatusBar_State of (Parent(hoClientArea)) to bOn
67633>>>>>        End
67633>>>>>>
67633>>>>>        Function_Return bOn
67634>>>>>    End_Function
67635>>>>>End_Class
67636>>>>>
67636>>>>>Class cCJAutoArrangeIconsMenuItem is a cCJMenuItem
67637>>>>>    
67637>>>>>    Procedure Construct_Object
67639>>>>>        Forward Send Construct_Object
67641>>>>>        Set psCaption to C_$CaptionAutoArrangeIcons
67642>>>>>        Set psToolTip to C_$ToolTipAutoArrangeIcons
67643>>>>>        Set psDescription to C_$DescAutoArrangeIcons
67644>>>>>        Set psCategory to C_$CategoryWindow
67645>>>>>    End_Procedure
67646>>>>>    
67646>>>>>    Procedure OnExecute Variant vCommandBarControl
67648>>>>>        Handle hoCommandBars hoClientArea
67648>>>>>        Get CommandBarSystemObject to hoCommandBars
67649>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67650>>>>>        If hoClientArea Begin
67652>>>>>            // the clientarea's parent panel has message
67652>>>>>            Send Toggle_Auto_Arrange_Icons of (Parent(hoClientArea))
67653>>>>>        End
67653>>>>>>
67653>>>>>    End_Procedure
67654>>>>>    
67654>>>>>    Function IsChecked Returns Boolean
67656>>>>>        Boolean bOn
67656>>>>>        Handle hoCommandBars hoClientArea
67656>>>>>        Get CommandBarSystemObject to hoCommandBars
67657>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67658>>>>>        If hoClientArea Begin
67660>>>>>            // the clientarea's parent panel has message
67660>>>>>            Get Auto_Arrange_Icons_State of (Parent(hoClientArea)) to bOn
67661>>>>>        End
67661>>>>>>
67661>>>>>        Function_Return bOn
67662>>>>>    End_Function
67663>>>>>End_Class
67664>>>>>
67664>>>>>Class cCJRestoreMenusMenuItem is a cCJMenuItem
67665>>>>>    
67665>>>>>    Procedure Construct_Object
67667>>>>>        Forward Send Construct_Object
67669>>>>>        Set psCaption to C_$CaptionRestoreMenus
67670>>>>>        Set psToolTip to C_$ToolTipRestoreMenus
67671>>>>>        Set psDescription to C_$DescRestoreMenus
67672>>>>>        Set psCategory to C_$CategoryWindow
67673>>>>>    End_Procedure
67674>>>>>    
67674>>>>>    Procedure OnExecute Variant vCommandBarControl
67676>>>>>        Handle hoCommandBars
67676>>>>>        Get CommandBarSystemObject to hoCommandBars
67677>>>>>        Send RestoreLayout of hoCommandBars
67678>>>>>    End_Procedure
67679>>>>>    
67679>>>>>End_Class
67680>>>>>
67680>>>>>Class cCJCascadeMenuItem is a cCJMenuItem
67681>>>>>    
67681>>>>>    Procedure Construct_Object
67683>>>>>        Forward Send Construct_Object
67685>>>>>        Set psCaption to C_$CaptionCascade
67686>>>>>        Set psToolTip to C_$ToolTipCascade
67687>>>>>        Set psDescription to  C_$DescCascade
67688>>>>>        Set psImage to "ActionCascade.ico"
67689>>>>>        Set psCategory to C_$CategoryWindow
67690>>>>>    End_Procedure
67691>>>>>    
67691>>>>>    Procedure OnExecute Variant vCommandBarControl
67693>>>>>        Handle hoCommandBars hoClientArea
67693>>>>>        Get CommandBarSystemObject to hoCommandBars
67694>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67695>>>>>        If hoClientArea Begin
67697>>>>>            Send Cascade_Windows of hoClientArea
67698>>>>>        End
67698>>>>>>
67698>>>>>    End_Procedure
67699>>>>>End_Class
67700>>>>>
67700>>>>>Class cCJTileHorizontally is a cCJMenuItem
67701>>>>>    
67701>>>>>    Procedure Construct_Object
67703>>>>>        Forward Send Construct_Object
67705>>>>>        Set psCaption to C_$CaptionTileHorizontally
67706>>>>>        Set psToolTip to C_$ToolTipTileHorizontally
67707>>>>>        Set psDescription to  C_$DescTileHorizontally
67708>>>>>        Set psImage to "ActionTileHorizontally.ico"
67709>>>>>        Set psCategory to C_$CategoryWindow
67710>>>>>    End_Procedure
67711>>>>>    
67711>>>>>    Procedure OnExecute Variant vCommandBarControl
67713>>>>>        Handle hoCommandBars hoClientArea
67713>>>>>        Get CommandBarSystemObject to hoCommandBars
67714>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67715>>>>>        If hoClientArea Begin
67717>>>>>            Send Tile_Windows_Horizontal of hoClientArea
67718>>>>>        End
67718>>>>>>
67718>>>>>    End_Procedure
67719>>>>>End_Class
67720>>>>>
67720>>>>>Class cCJTileVertically is a cCJMenuItem
67721>>>>>    
67721>>>>>    Procedure Construct_Object
67723>>>>>        Forward Send Construct_Object
67725>>>>>        Set psCaption to C_$CaptionTileVertically
67726>>>>>        Set psToolTip to C_$ToolTipTileVertically
67727>>>>>        Set psDescription to  C_$DescTileVertically
67728>>>>>        Set psImage to "ActionTileVertically.ico"
67729>>>>>        Set psCategory to C_$CategoryWindow
67730>>>>>    End_Procedure
67731>>>>>    
67731>>>>>    Procedure OnExecute Variant vCommandBarControl
67733>>>>>        Handle hoCommandBars hoClientArea
67733>>>>>        Get CommandBarSystemObject to hoCommandBars
67734>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67735>>>>>        If hoClientArea Begin
67737>>>>>            Send Tile_Windows_Vertical of hoClientArea
67738>>>>>        End
67738>>>>>>
67738>>>>>    End_Procedure
67739>>>>>End_Class
67740>>>>>
67740>>>>>Class cCJMinimizeWindowsMenuItem is a cCJMenuItem
67741>>>>>    
67741>>>>>    Procedure Construct_Object
67743>>>>>        Forward Send Construct_Object
67745>>>>>        Set psCaption to C_$CaptionMinimizeWindows
67746>>>>>        Set psToolTip to C_$ToolTipMinimizeWindows
67747>>>>>        Set psDescription to  C_$DescMinimizeWindows
67748>>>>>        Set psCategory to C_$CategoryWindow
67749>>>>>    End_Procedure
67750>>>>>    
67750>>>>>    Procedure OnExecute Variant vCommandBarControl
67752>>>>>        Handle hoCommandBars hoClientArea
67752>>>>>        Get CommandBarSystemObject to hoCommandBars
67753>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67754>>>>>        If hoClientArea Begin
67756>>>>>            // the clientarea's parent panel has message
67756>>>>>            Send Minimize_all_Windows of (Parent(hoClientArea))
67757>>>>>        End
67757>>>>>>
67757>>>>>    End_Procedure
67758>>>>>End_Class
67759>>>>>
67759>>>>>
67759>>>>>Class cCJRestoreWindowsMenuItem is a cCJMenuItem
67760>>>>>    
67760>>>>>    Procedure Construct_Object
67762>>>>>        Forward Send Construct_Object
67764>>>>>        Set psCaption to C_$CaptionRestoreWindows
67765>>>>>        Set psToolTip to C_$ToolTipRestoreWindows
67766>>>>>        Set psDescription to  C_$DescRestoreWindows
67767>>>>>        Set psCategory to C_$CategoryWindow
67768>>>>>    End_Procedure
67769>>>>>    
67769>>>>>    Procedure OnExecute Variant vCommandBarControl
67771>>>>>        Handle hoCommandBars hoClientArea
67771>>>>>        Get CommandBarSystemObject to hoCommandBars
67772>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67773>>>>>        If hoClientArea Begin
67775>>>>>            // the clientarea's parent panel has message
67775>>>>>            Send Restore_all_Windows of (Parent(hoClientArea))
67776>>>>>        End
67776>>>>>>
67776>>>>>    End_Procedure
67777>>>>>End_Class
67778>>>>>
67778>>>>>Class cCJArrangeIconsMenuItem is a cCJMenuItem
67779>>>>>    
67779>>>>>    Procedure Construct_Object
67781>>>>>        Forward Send Construct_Object
67783>>>>>        Set psCaption to C_$CaptionArrangeIcons
67784>>>>>        Set psToolTip to C_$ToolTipArrangeIcons
67785>>>>>        Set psDescription to  C_$DescArrangeIcons
67786>>>>>        Set psCategory to C_$CategoryWindow
67787>>>>>    End_Procedure
67788>>>>>    
67788>>>>>    Procedure OnExecute Variant vCommandBarControl
67790>>>>>        Handle hoCommandBars hoClientArea
67790>>>>>        Get CommandBarSystemObject to hoCommandBars
67791>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67792>>>>>        If hoClientArea Begin
67794>>>>>            Send Arrange_Icons of hoClientArea
67795>>>>>        End
67795>>>>>>
67795>>>>>    End_Procedure
67796>>>>>    
67796>>>>>End_Class
67797>>>Use cCJAboutMenuItem.pkg
Including file: cCJAboutMenuItem.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCJAboutMenuItem.pkg)
67797>>>>>Use cCJCommandBarSystem.pkg
67797>>>>>Use LanguageText.pkg
67797>>>>>
67797>>>>>// It is expected that if you use this class that you provide an about object that is
67797>>>>>// activated via activate_about such as DfAbout.pkg. We don't use this for you automatically
67797>>>>>// because you may wish to create your own custom about package.
67797>>>>>
67797>>>>>Class cCJAboutMenuItem is a cCJMenuItem    
67798>>>>>
67798>>>>>    Procedure Construct_Object
67800>>>>>        Forward Send Construct_Object
67802>>>>>        Set psCaption to C_$CaptionAbout
67803>>>>>        Set psDescription to C_$ToolTipAbout
67804>>>>>        Set psToolTip to C_$DescAbout
67805>>>>>        Set psImage to "ActionAbout.ico"
67806>>>>>        Set psCategory to C_$CategoryHelp
67807>>>>>    End_Procedure
67808>>>>>    
67808>>>>>    Procedure OnExecute Variant vCommandBarControl
67810>>>>>        Handle hoCommandBars hoClientArea
67810>>>>>        Get CommandBarSystemObject to hoCommandBars
67811>>>>>        Get ClientAreaObject of hoCommandBars to hoClientArea
67812>>>>>        If hoClientArea Begin
67814>>>>>            Send Activate_About of hoClientArea
67815>>>>>        End
67815>>>>>>
67815>>>>>    End_Procedure
67816>>>>>
67816>>>>>End_Class
67817>>>>>
67817>>>>>
67817>>>Use cCJDeoMenuItemClasses.pkg
67817>>>Use cCJMDIWindowsMenuItem.pkg
Including file: cCJMDIWindowsMenuItem.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cCJMDIWindowsMenuItem.pkg)
67817>>>>>Use cCJCommandBarSystem.pkg
67817>>>>>
67817>>>>>Register_Function Client_ID Returns Integer
67817>>>>>
67817>>>>>// only used by cCJMDIWIndowsMenuItem
67817>>>>>Class cCJMDIWindowItem is a cCJMenuItem
67818>>>>>    
67818>>>>>    Procedure Construct_Object
67820>>>>>        Forward Send Construct_Object
67822>>>>>        Property Handle phWindow 0 // object id of view
67823>>>>>        Set pbControlFlagNoMovable to True
67824>>>>>        Set pbActiveUpdate to True
67825>>>>>    End_Procedure
67826>>>>>    
67826>>>>>    Procedure OnExecute Variant vCommandBarControl
67828>>>>>        Handle hWindow
67828>>>>>        Get phWindow to hWindow
67829>>>>>        Send Activate_View of hWindow
67830>>>>>    End_Procedure
67831>>>>>    
67831>>>>>End_Class
67832>>>>>
67832>>>>>
67832>>>>>Class cCJMDIWindowsMenuItem is a cCJMenuItem
67833>>>>>    
67833>>>>>    Procedure Construct_Object
67835>>>>>        Forward Send Construct_Object
67837>>>>>        Property Handle[] phArrayOfWindows
67838>>>>>        Set peControlType to xtpControlPopup
67839>>>>>        Set psCategory to C_$CategoryWindow
67840>>>>>    End_Procedure
67841>>>>>    
67841>>>>>    // This adds MDI windows to the existing menu items.
67841>>>>>    // This removes any existing windows menus and always adds a new set to the end
67841>>>>>    
67841>>>>>    Procedure OnPopupInit Variant vCommandBarControl Handle hCommandBarControls
67843>>>>>        Handle  hClientArea hView
67843>>>>>        String  sLabel
67843>>>>>        Integer i iWindows
67843>>>>>        Handle[] hArrayOfWindows
67844>>>>>        Variant vItem
67844>>>>>        
67844>>>>>        // delete all windows actions and menu items. Assume we have an array of DF action objects for the windows
67844>>>>>        // also assume that destroying an action removes all menu instances of that action
67844>>>>>        Get phArrayOfWindows to hArrayOfWindows
67845>>>>>        Move (SizeOfArray(hArrayOfWindows)) to iWindows
67846>>>>>        For i from 0 to (iWindows-1)
67852>>>>>>
67852>>>>>            Send Destroy of hArrayOfWindows[i] // assume this removes all menu items of this action
67853>>>>>        Loop
67854>>>>>>
67854>>>>>        Move (ResizeArray(hArrayOfWindows,0)) to hArrayOfWindows
67855>>>>>        
67855>>>>>        // Add all views to this menu. Create the action and add the item
67855>>>>>        Move 0 to i
67856>>>>>        Get Client_Id to hClientArea // object id of client area
67857>>>>>        If (hClientArea > 0) Begin
67859>>>>>            Get Next_Mdi_Dialog of hClientArea True to hView // find first view
67860>>>>>            While (hView <> 0)
67864>>>>>                If (Active_State(hView)) Begin
67866>>>>>                    // create the action
67866>>>>>                    Get Create U_cCJMDIWindowItem to hArrayOfWindows[i]
67867>>>>>                    Get Label of hView to sLabel // caption bar (name) of view
67868>>>>>                    Set psCaption of hArrayOfWindows[i] to sLabel
67869>>>>>                    Set psDescription of hArrayOfWindows[i] to ("Make this view (" - trim(sLabel) - ") the active window.")
67870>>>>>                    If (current_scope(desktop)=hView and View_mode(hView)<>VIEWMODE_ICONIZE) Begin
67872>>>>>                        Set pbChecked of hArrayOfWindows[i] to True
67873>>>>>                    End
67873>>>>>>
67873>>>>>                    Set phWindow of hArrayOfWindows[i] to hView // used by custom OnExecute
67874>>>>>                    If (i=0) Begin
67876>>>>>                        Set pbControlBeginGroup of hArrayOfWindows[i] to True
67877>>>>>                    End
67877>>>>>>
67877>>>>>                    // Create a menu item for this action
67877>>>>>                    Get AddDynamicControl of hArrayOfWindows[i] hCommandBarControls to vItem
67878>>>>>                    Increment i
67879>>>>>                End
67879>>>>>>
67879>>>>>                Get Next_Mdi_Dialog of hClientArea False to hView // find next
67880>>>>>            Loop
67881>>>>>>
67881>>>>>        End
67881>>>>>>
67881>>>>>        
67881>>>>>        Set phArrayOfWindows to hArrayOfWindows
67882>>>>>        
67882>>>>>    End_Procedure
67883>>>>>    
67883>>>>>End_Class
67884>Use StdAbout.pkg
Including file: StdAbout.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\StdAbout.pkg)
67884>>>// This provides a quick and simple way to create an about package for a program.
67884>>>// You need to create a message inside you client area called Activate_About.
67884>>>// Within this message you should send the message DoAbout passing needed
67884>>>// string information.
67884>>>//
67884>>>//       Procedure Activate_About
67884>>>//           Send DoAbout sTitle sVersion sCopyright sAuthor sBitmap
67884>>>//       End_Procedure
67884>>>//    where: sTitle =     Name of application. If none provided, uses caption
67884>>>//                        bar title
67884>>>//           sVersion   = Version Line. If none provided, will be blank
67884>>>//           sCopyRight = Copyright Line. If none provided, will be blank
67884>>>//           sAuthor    = Author name, blank if none provided
67884>>>//           sBitMap    = Bitmap logo. If none provided, standard VDF bitmap
67884>>>//                        is used.
67884>>>// It is expected that you will place this in your own object package. For
67884>>>// example an order about package may look like this:
67884>>>//
67884>>>//   // OrderAbout.pkg
67884>>>//   Use StdAbout.pkg
67884>>>//   Procedure Activate_About
67884>>>//      String sTitle sCopyright sVersion sAuthor
67884>>>//      Move "My Order Entry System" to sTitle
67884>>>//      Move "Version 2.1" to sVersion
67884>>>//      Move "Copyright xxxx, Super Software Inc." to sCopyright
67884>>>//      Move "John Smith"  to sAuthor
67884>>>//      Send DoAbout sTitle sVersion sCopyright sAuthor ""
67884>>>//   end_procedure
67884>>>//   // end of file.
67884>>>
67884>>>Use DfAbout.pkg
Including file: Dfabout.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\Dfabout.pkg)
67884>>>>>Use LanguageText.pkg
67884>>>>>Use Windows.pkg
67884>>>>>Use DFbitmap.pkg
67884>>>>>Use GlobalFunctionsProcedures.pkg
67884>>>>>Use cTextEdit.pkg
67884>>>>>Use tWinStructs.pkg
67884>>>>>
67884>>>>>Use cli.pkg
67884>>>>>Use DFBTRDRV.PKG
Including file: DFBTRDRV.PKG    (C:\Program Files (x86)\DataFlex 19.1\Pkg\DFBTRDRV.PKG)
67884>>>>>>>// $File title : Package for the DataFlex Connectivity Kit for Pervasive.SQL
67884>>>>>>>// Notice      : This package contains constants and commands, used to call
67884>>>>>>>//               specific functions in the DFBTRDRV.
67884>>>>>>>Use Ui
67884>>>>>>>//
67884>>>>>>>// Driver Indentification
67884>>>>>>>//
67884>>>>>>>
67884>>>>>>>// Driver attributes
67884>>>>>>>//
67884>>>>>>>// Call_Driver functions ID's
67884>>>>>>>//
67884>>>>>>>//
67884>>>>>>>// DFBTRFN_CONVERT_FILE options
67884>>>>>>>//
67884>>>>>>>
67884>>>>>>>//
67884>>>>>>>// DFBTRFN_SET_OWNER options
67884>>>>>>>//
67884>>>>>>>
67884>>>>>>>//
67884>>>>>>>// DFBTRFN_SET_TRANSACTION_TYPE options
67884>>>>>>>//
67884>>>>>>>
67884>>>>>>>
67884>>>>>>>//
67884>>>>>>>// Command to create all vars which may be needed
67884>>>>>>>// in other commands.
67884>>>>>>>//
67884>>>>>>>
67884>>>>>>>
67884>>>>>>>
67884>>>>>>>//
67884>>>>>>>// Command to set the owner of a Btrieve file.
67884>>>>>>>// File must have been opened.
67884>>>>>>>// Filenumber needs to be passed.
67884>>>>>>>// To clear set the owner to "".
67884>>>>>>>// Examples:
67884>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret"
67884>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY CALLBACK MyCallBack
67884>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" ENCRYPT
67884>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to "Secret" READONLY ENCRYPT CALLBACK MyCallBack
67884>>>>>>>// To clear:
67884>>>>>>>//      DFBTR_SET_OWNER MyFileNumber to ""
67884>>>>>>>//
67884>>>>>>>
67884>>>>>>>
67884>>>>>>>
67884>>>>>>>//
67884>>>>>>>// Command to parse DFBTR_SET_OWNVER
67884>>>>>>>// options.
67884>>>>>>>//
67884>>>>>>>
67884>>>>>>>
67884>>>>>>>
67884>>>>>>>//
67884>>>>>>>// Command to parse for Callback
67884>>>>>>>//
67884>>>>>>>
67884>>>>>>>
67884>>>>>>>
67884>>>>>>>//
67884>>>>>>>// Command to clear the owner of a Btrieve file.
67884>>>>>>>// File must have been opened.
67884>>>>>>>// Filenumber needs to be passed.
67884>>>>>>>// Examples:
67884>>>>>>>//      DFBTR_CLEAR_OWNER MyFileNumber
67884>>>>>>>//
67884>>>>>>>
67884>>>>>>>
67884>>>>>>>
67884>>>>>>>//
67884>>>>>>>// Command to add a owner name to the internal list of ownernames
67884>>>>>>>// which will be tries when opening files.
67884>>>>>>>//
67884>>>>>>>
67884>>>>>>>
67884>>>>>>>
67884>>>>>>>//
67884>>>>>>>// Command to remove all owners from the internal list of ownernames
67884>>>>>>>//
67884>>>>>>>
67884>>>>>>>
67884>>>>>>>//
67884>>>>>>>// Command to set the owner name to be used when opening the DDF files.
67884>>>>>>>// The DDF owner is required when Pervasive.SQL security is turned on.
67884>>>>>>>// The DDF owner is equal to the password of the Master user in Pervasive.SQL
67884>>>>>>>// This command overwrites the DDF_OWNER setting in DFBTRDRV.INT
67884>>>>>>>//
67884>>>>>>>
67884>>>>>>>//
67884>>>>>>>// Command to change the transaction type.
67884>>>>>>>// Valid types are:
67884>>>>>>>//     DFBTRTT_NONE
67884>>>>>>>//     DFBTRTT_EXCLUSIVE
67884>>>>>>>//     DFBTRTT_CONCURRENT
67884>>>>>>>//
67884>>>>>>>//
67884>>>>>>>
67884>>>>>>>
67884>>>>>>>
67884>>>>>>>//
67884>>>>>>>// Command to get the current transaction type.
67884>>>>>>>//
67884>>>>>>>
67884>>>>>>>//
67884>>>>>>>// Command to set explicit_locking
67884>>>>>>>//
67884>>>>>>>
67884>>>>>>>//
67884>>>>>>>// Command to get explicit locking
67884>>>>>>>//
67884>>>>>>>
67884>>>>>>>//
67884>>>>>>>// Command to set detection for incompatible positive signs in numeric fields
67884>>>>>>>//
67884>>>>>>>
67884>>>>>>>//
67884>>>>>>>// Command to get detection for incompatible positive signs in numeric fields
67884>>>>>>>//
67884>>>>>>>
67884>>>>>>>// Purpose: An instance of this class can be used as a broker object to
67884>>>>>>>//          call several Dfbtrdrv releated methods.
67884>>>>>>>
67884>>>>>>>Class cDFBtrDrvHandler is an Array
67885>>>>>>>    
67885>>>>>>>    Procedure Construct_Object Integer iImage
67887>>>>>>>        Forward Send Construct_object iImage
67889>>>>>>>        
67889>>>>>>>        Property String  psDriverID "DFBTRDRV"
67890>>>>>>>    End_Procedure
67891>>>>>>>    
67891>>>>>>>    //  The revsion of a Dfbtrdrv Connectivity Kit
67891>>>>>>>    //
67891>>>>>>>    
67891>>>>>>>    Function CKRevision Returns String
67893>>>>>>>        String  sDriverID
67893>>>>>>>        String  sRevision
67893>>>>>>>        String  sVoid
67893>>>>>>>        Integer iRetval
67893>>>>>>>        
67893>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
67893>>>>>>>        // This error would otherwise be raised when we have an older
67893>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
67893>>>>>>>        Send Ignore_error to Error_object_Id 20491
67894>>>>>>>        Get psDriverID to sDriverID
67895>>>>>>>        Move (Repeat(" ", 255)) to sRevision
67896>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKREVISION Callback 0 Passing sRevision sVoid 0 Result iRetval
67901>>>>>>>        Send Trap_Error to Error_object_Id 20491
67902>>>>>>>        If (Trim(sRevision) = "") Begin
67904>>>>>>>            // Unable to get the revision. return all zeroes.
67904>>>>>>>            Move "0.0.0.0" to sRevision
67905>>>>>>>        End
67905>>>>>>>>
67905>>>>>>>        Function_Return sRevision
67906>>>>>>>    End_Function
67907>>>>>>>    
67907>>>>>>>    Function CkUsesUri Returns Integer
67909>>>>>>>        String  sDriverID
67909>>>>>>>        String  sVoid1
67909>>>>>>>        String  sVoid2
67909>>>>>>>        Integer iRetval
67909>>>>>>>        
67909>>>>>>>        Get psDriverID to sDriverID
67910>>>>>>>        
67910>>>>>>>        Move 0 to iRetval
67911>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
67911>>>>>>>        // This error would otherwise be raised when we have an older
67911>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKUSESURI function
67911>>>>>>>        Send Ignore_error to Error_object_Id 20491
67912>>>>>>>        Call_Driver 0 sDRiverID Function DFBTRFN_CKUSESURI Callback 0 Passing sVoid1 sVoid2 0 Result iRetval
67917>>>>>>>        Send Trap_Error to Error_object_Id 20491
67918>>>>>>>        
67918>>>>>>>        Function_Return iRetval
67919>>>>>>>    End_Function
67920>>>>>>>    
67920>>>>>>>    
67920>>>>>>>    
67920>>>>>>>    // Extract the Nth part of a a.b.c.d revsion string.
67920>>>>>>>    //
67920>>>>>>>    // Returns : The part version number or -1 if there is no such part number.
67920>>>>>>>    //
67920>>>>>>>    
67920>>>>>>>    Function ExtractPartFromRevision Integer iPartNum String sRevision Returns Integer
67922>>>>>>>        Integer iPartRev
67922>>>>>>>        Integer iCurrentPart
67922>>>>>>>        Integer iSeparatorPos
67922>>>>>>>        
67922>>>>>>>        If (iPartNum > 4) ;            Function_Return -1
67925>>>>>>>        
67925>>>>>>>        Move 0 to iCurrentPart
67926>>>>>>>        Repeat
67926>>>>>>>>
67926>>>>>>>            Move (Pos(".", sRevision)) to iSeparatorPos
67927>>>>>>>            If (iSeparatorPos > 0) Begin
67929>>>>>>>                Move (Left(sRevision, iSeparatorPos - 1)) to iPartRev
67930>>>>>>>                Move (Right(sRevision, Length(sRevision) - iSeparatorPos)) to sRevision
67931>>>>>>>                Increment iCurrentPart
67932>>>>>>>            End
67932>>>>>>>>
67932>>>>>>>            Else If (sRevision <> "") Begin
67935>>>>>>>                Move sRevision to iPartRev
67936>>>>>>>                Move "" to sRevision
67937>>>>>>>                Increment iCurrentPart
67938>>>>>>>            End
67938>>>>>>>>
67938>>>>>>>            Else ;                Move -1 to iPartRev
67940>>>>>>>        Until (iCurrentPart >= iPartNum or iPartRev = -1)
67942>>>>>>>        
67942>>>>>>>        Function_Return iPartRev
67943>>>>>>>    End_Function
67944>>>>>>>    
67944>>>>>>>    
67944>>>>>>>    
67944>>>>>>>    //
67944>>>>>>>    //  Returns the major revision of the CK
67944>>>>>>>    //
67944>>>>>>>    
67944>>>>>>>    Function CKMajorRevision Returns Integer
67946>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 1, CKRevision(Current_Object)))
67947>>>>>>>    End_Function
67948>>>>>>>    
67948>>>>>>>    
67948>>>>>>>    
67948>>>>>>>    //  Returns the minor revision of the CK
67948>>>>>>>    //
67948>>>>>>>    
67948>>>>>>>    Function CKMinorRevision Returns Integer
67950>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 2, CKRevision(Current_Object)))
67951>>>>>>>    End_Function
67952>>>>>>>    
67952>>>>>>>    
67952>>>>>>>    //  Returns the release revision of the CK
67952>>>>>>>    //
67952>>>>>>>    
67952>>>>>>>    Function CKReleaseRevision Returns Integer
67954>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 3, CKRevision(Current_Object)))
67955>>>>>>>    End_Function
67956>>>>>>>    
67956>>>>>>>    
67956>>>>>>>    //  Returns the major revision of the CK
67956>>>>>>>    //
67956>>>>>>>    
67956>>>>>>>    Function CKBuildRevision Returns Integer
67958>>>>>>>        Function_Return (ExtractPartFromRevision (Current_Object, 4, CKRevision(Current_Object)))
67959>>>>>>>    End_Function
67960>>>>>>>    
67960>>>>>>>    
67960>>>>>>>    //  Determines if the CK conforms to a passed minimal revsion.
67960>>>>>>>    //
67960>>>>>>>    
67960>>>>>>>    Function IsMinimalRevision Integer iMajor Integer iMinor Integer iRelease Integer iBuild Returns Integer
67962>>>>>>>        If (iMajor < CKMajorRevision(Current_object)) ;            Function_Return (True)
67965>>>>>>>        Else If (iMajor = CKMajorRevision(Current_object)) Begin
67968>>>>>>>            If (iMinor < CKMinorRevision(Current_object)) ;                Function_Return (True)
67971>>>>>>>            Else If (iMinor = CKMinorRevision(Current_object)) Begin
67974>>>>>>>                If (iRelease < CKReleaseRevision(Current_object)) ;                    Function_Return (True)
67977>>>>>>>                Else If (iRelease = CKReleaseRevision(Current_object) and iBuild <= CKBuildRevision(Current_object)) ;                    Function_Return (True)
67981>>>>>>>            End
67981>>>>>>>>
67981>>>>>>>        End
67981>>>>>>>>
67981>>>>>>>        
67981>>>>>>>        Function_Return (False)
67982>>>>>>>    End_Function
67983>>>>>>>    
67983>>>>>>>    //   Functions to query the Pervasive.SQL version:
67983>>>>>>>    //       PSQLRequesterVersionInfo    Integer iFileNum Returns String
67983>>>>>>>    //       PSQLLocalEngineVersionInfo  Integer iFileNum Returns String
67983>>>>>>>    //       PSQLServerEngineVersionInfo Integer iFileNum Returns String
67983>>>>>>>    //
67983>>>>>>>    //   All 3 functions return the version of a Pervasive.SQL component
67983>>>>>>>    //   in the following format:
67983>>>>>>>    //       <version>.<revision>.<type>
67983>>>>>>>    //   possible values for <type>:
67983>>>>>>>    //       9 for 32-bit Windows workstation/workgroup engine or Linux
67983>>>>>>>    //         server using Workgroup authentication mode
67983>>>>>>>    //       C for client cache engine
67983>>>>>>>    //       D for DOS workstation
67983>>>>>>>    //       N for client Requester
67983>>>>>>>    //       S for NetWare server
67983>>>>>>>    //       T for 32-bit Windows server engine
67983>>>>>>>    //       U for Linux server using PAM or BTPASSWD authentication
67983>>>>>>>    //
67983>>>>>>>    //   example:
67983>>>>>>>    //       8.50.T
67983>>>>>>>    //   will be returned for a Pervasive.SQL 8.5 Server Engine running on
67983>>>>>>>    //   32-bits Windows server.
67983>>>>>>>    //
67983>>>>>>>    //   The FileNumber parameter must specify an opened table or 0.
67983>>>>>>>    //   For PSQLServerEngineVersionInfo the FileNumber can not be 0.
67983>>>>>>>    //
67983>>>>>>>    //   If the version information is not available or can not be obtained
67983>>>>>>>    //   the functions will return "0.0.0"
67983>>>>>>>    
67983>>>>>>>    //  Returns the version information of the
67983>>>>>>>    //           Pervasive.SQL Client requester.
67983>>>>>>>    
67983>>>>>>>    Function PSQLRequesterVersionInfo Integer iFileNum Returns String
67985>>>>>>>        
67985>>>>>>>        String  sDriverID
67985>>>>>>>        String  sVersion
67985>>>>>>>        String  sVoid
67985>>>>>>>        Integer iRetval
67985>>>>>>>        
67985>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
67985>>>>>>>        // This error would otherwise be raised when we have an older
67985>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
67985>>>>>>>        Send Ignore_error to Error_object_Id 20491
67986>>>>>>>        Get psDriverID to sDriverID
67987>>>>>>>        Move (Repeat(" ", 255)) to sVersion
67988>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLREQUESTERVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
67993>>>>>>>        Send Trap_Error to Error_object_Id 20491
67994>>>>>>>        If (Trim(sVersion) = "") Begin
67996>>>>>>>            // Unable to get the revision. return all zeroes.
67996>>>>>>>            Move "0.0.0" to sVersion
67997>>>>>>>        End
67997>>>>>>>>
67997>>>>>>>        Function_Return sVersion
67998>>>>>>>    End_Function
67999>>>>>>>    
67999>>>>>>>    //           Pervasive.SQL Engine
67999>>>>>>>    
67999>>>>>>>    Function PSQLLocalEngineVersionInfo Integer iFileNum Returns String
68001>>>>>>>        
68001>>>>>>>        String  sDriverID
68001>>>>>>>        String  sVersion
68001>>>>>>>        String  sVoid
68001>>>>>>>        Integer iRetval
68001>>>>>>>        
68001>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
68001>>>>>>>        // This error would otherwise be raised when we have an older
68001>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
68001>>>>>>>        Send Ignore_error to Error_object_Id 20491
68002>>>>>>>        Get psDriverID to sDriverID
68003>>>>>>>        Move (Repeat(" ", 255)) to sVersion
68004>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLLOCALENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
68009>>>>>>>        Send Trap_Error to Error_object_Id 20491
68010>>>>>>>        If (Trim(sVersion) = "") Begin
68012>>>>>>>            // Unable to get the revision. return all zeroes.
68012>>>>>>>            Move "0.0.0" to sVersion
68013>>>>>>>        End
68013>>>>>>>>
68013>>>>>>>        Function_Return sVersion
68014>>>>>>>    End_Function
68015>>>>>>>    
68015>>>>>>>    //  Returns the version information of the
68015>>>>>>>    //           Pervasive.SQL Server Engine
68015>>>>>>>    
68015>>>>>>>    Function PSQLServerEngineVersionInfo Integer iFileNum Returns String
68017>>>>>>>        
68017>>>>>>>        String  sDriverID
68017>>>>>>>        String  sVersion
68017>>>>>>>        String  sVoid
68017>>>>>>>        Integer iRetval
68017>>>>>>>        
68017>>>>>>>        // Ignore error 20491 DFBTRERR_INVALID_DRIVER_FUNCTION_CALL.
68017>>>>>>>        // This error would otherwise be raised when we have an older
68017>>>>>>>        // DFBTRDRV version that has no DFBTRFN_CKREVISION function
68017>>>>>>>        Send Ignore_error to Error_object_Id 20491
68018>>>>>>>        Get psDriverID to sDriverID
68019>>>>>>>        Move (Repeat(" ", 255)) to sVersion
68020>>>>>>>        Call_Driver iFileNum sDRiverID Function DFBTRFN_PSQLSERVERENGINEVERSIONINFO Callback 0 Passing sVersion sVoid 0 Result iRetval
68025>>>>>>>        Send Trap_Error to Error_object_Id 20491
68026>>>>>>>        If (Trim(sVersion) = "") Begin
68028>>>>>>>            // Unable to get the revision. return all zeroes.
68028>>>>>>>            Move "0.0.0" to sVersion
68029>>>>>>>        End
68029>>>>>>>>
68029>>>>>>>        Function_Return sVersion
68030>>>>>>>    End_Function
68031>>>>>>>    
68031>>>>>>>End_Class
68032>>>>>>>
68032>>>>>>>
68032>>>>>Use MSSqldrv.pkg
Including file: MSSqldrv.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\MSSqldrv.pkg)
68032>>>>>>>//     Package that declares MS SQL driver constants and functions.
68032>>>>>>>//     This package can be used by developers who want to add Data Access
68032>>>>>>>//     MS SQL Client specific code to a DataFlex application.
68032>>>>>>>
68032>>>>>>>Use Cli.pkg
68032>>>>>>>Use SQL.pkg
68032>>>>>>>
68032>>>>>>>//   Driver Indentification
68032>>>>>>>
68032>>>>>>>//   Error number constants
68032>>>>>>>
68032>>>>>>>
68032>>>>>>>//   Possible DF_DRIVER_SQLSERVER_CLIENT_VERSION values
68032>>>>>>>
68032>>>>>>>
68032>>>>>>>
68032>>>>>>>
68032>>>>>>>
68032>>>>>>>
68032>>>>>>>// SQL Server spcific types.
68032>>>>>>>Define SQL_SS_TIMESTAMPOFFSET   for   (-155) //SQL server datetimeoffset type */
68032>>>>>>>Define SQL_SS_TIME2             for   (-154) //SQL server time type */
68032>>>>>>>Define SQL_SS_XML               for   (-152) //SQL server xml type */
68032>>>>>>>Define SQL_SS_VARIANT           for   (-150) //SQL server variant type */
68032>>>>>>>
68032>>>>>>>// SQL Server spcific types.
68032>>>>>>>Define SQL_TYPE_TIMESTAMP2      for   (-200) //SQL server datetime2 type */
68032>>>>>>>Define SQL_VARCHARMAX           for   (-201) //SQL server varchar(max) type */
68032>>>>>>>Define SQL_WVARCHARMAX          for   (-202) //SQL server wvarchar(max) type */
68032>>>>>>>Define SQL_VARBINARYMAX         for   (-203) //SQL server varbinary(max) type */
68032>>>>>>>Define SQL_TYPE_MONEY           for   (-204) //SQL server money type */
68032>>>>>>>Define SQL_TYPE_SMALLMONEY      for   (-205) //SQL server smallmoney type */
68032>>>>>>>Define SQL_TYPE_SMALLDATETIME   for   (-206) //SQL server smalldatetype type */
68032>>>>>>>
68032>>>>>>>
68032>>>>>>>//   MSSQL_SetConstraint <FileNum> <ConstraintText>
68032>>>>>>>//
68032>>>>>>>//     Setup a constraint for a file.
68032>>>>>>>
68032>>>>>>>
68032>>>>>>>Class cMSSQLHandler is a cCLIHandler
68033>>>>>>>    
68033>>>>>>>    Procedure Construct_Object
68035>>>>>>>        Forward Send Construct_Object
68037>>>>>>>        
68037>>>>>>>        Set psDriverID to MSSQLDRV_ID
68038>>>>>>>    End_Procedure
68039>>>>>>>    
68039>>>>>>>    
68039>>>>>>>    
68039>>>>>>>    //   Extract the list from the out connect string.
68039>>>>>>>    Function ExtractList String sOutConnStr Integer hoStore Returns Integer
68041>>>>>>>        String  sItem
68041>>>>>>>        Integer iStart
68041>>>>>>>        Integer iEnd
68041>>>>>>>        
68041>>>>>>>        If (hoStore = 0) ;            Move Current_object to hoStore
68044>>>>>>>        
68044>>>>>>>        Send Delete_Data to hoStore
68045>>>>>>>        Move (Pos("{", sOutConnStr)) to iStart
68046>>>>>>>        While (iStart > 0)
68050>>>>>>>            Move (Right(sOutConnStr, Length(sOutConnStr) - iStart)) to sOutConnStr
68051>>>>>>>            If (Left(sOutConnStr, 1) = "}") ;                Move 0 to iStart
68054>>>>>>>            Else Begin
68055>>>>>>>                Move (Pos(",", sOutConnStr)) to iStart
68056>>>>>>>                Move (Pos("}", sOutConnStr)) to iEnd
68057>>>>>>>                If ((iStart = 0) or (iEnd < iStart)) ;                    Move iEnd to iStart
68060>>>>>>>                
68060>>>>>>>                If (iStart > 0) ;                    Set Value of hoStore  (Item_Count(Current_Object)) to (Left(sOutConnStr, iStart - 1))
68063>>>>>>>                
68063>>>>>>>                If (iStart = iEnd) ;                    Move 0 to iStart
68066>>>>>>>            End
68066>>>>>>>>
68066>>>>>>>        Loop
68067>>>>>>>>
68067>>>>>>>        
68067>>>>>>>        Function_Return (Item_Count(hoStore))
68068>>>>>>>    End_Function
68069>>>>>>>    
68069>>>>>>>    
68069>>>>>>>    
68069>>>>>>>    //   Call the driver's browse connect function
68069>>>>>>>    Function BrowseConnect String sInConnStr Returns String
68071>>>>>>>        String  sDriver
68071>>>>>>>        String  sOutConnStr
68071>>>>>>>        Integer iArg
68071>>>>>>>        Integer iRetval
68071>>>>>>>        
68071>>>>>>>        Get psDriverID to sDriver
68072>>>>>>>        If (sDriver <> "") Begin
68074>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
68075>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
68080>>>>>>>        End
68080>>>>>>>>
68080>>>>>>>        
68080>>>>>>>        Function_Return sOutConnStr
68081>>>>>>>    End_Function// BrowseConnect
68082>>>>>>>    
68082>>>>>>>    
68082>>>>>>>    Function BrowseConnectLocal String sInConnStr Returns String
68084>>>>>>>        String  sDriver
68084>>>>>>>        String  sOutConnStr
68084>>>>>>>        Integer iArg
68084>>>>>>>        Integer iRetval
68084>>>>>>>        
68084>>>>>>>        Move 1 to iArg // Browses only local
68085>>>>>>>        
68085>>>>>>>        Get psDriverID to sDriver
68086>>>>>>>        If (sDriver <> "") Begin
68088>>>>>>>            Move (Repeat(" ", 8192)) to sOutConnStr
68089>>>>>>>            Call_Driver 0 sDRiver Function CLI_BROWSECONNECT Callback 0 Passing sInConnStr sOutConnStr iArg Result iRetval
68094>>>>>>>        End
68094>>>>>>>>
68094>>>>>>>        
68094>>>>>>>        Function_Return sOutConnStr
68095>>>>>>>    End_Function// BrowseConnect
68096>>>>>>>    
68096>>>>>>>    
68096>>>>>>>    Function EnumerateServersNetworkOrLocal Integer iNetworkLocal  Returns Integer
68098>>>>>>>        
68098>>>>>>>        String  sServerList
68098>>>>>>>        Integer iNumServers
68098>>>>>>>        Integer iDriver
68098>>>>>>>        Integer iClientVersion
68098>>>>>>>        String  sDriver
68098>>>>>>>        
68098>>>>>>>        Get DriverIndex MSSQLDRV_ID to iDriver
68099>>>>>>>        
68099>>>>>>>        If (iDriver) Begin
68101>>>>>>>            
68101>>>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iDriver to iClientVersion
68104>>>>>>>            
68104>>>>>>>            Get SqlServerClientDriverName iClientVersion to sDriver
68105>>>>>>>            
68105>>>>>>>            Move ("DRIVER={" + sDriver + "};") to sDriver
68106>>>>>>>            If (iNetworkLocal = 0) Begin
68108>>>>>>>                Get BrowseConnect sDriver to sServerList
68109>>>>>>>            End
68109>>>>>>>>
68109>>>>>>>            Else Begin
68110>>>>>>>                Get BrowseConnectLocal sDriver to sServerList
68111>>>>>>>            End
68111>>>>>>>>
68111>>>>>>>            Get ExtractList sServerList Current_object to iNumServers
68112>>>>>>>        End
68112>>>>>>>>
68112>>>>>>>        
68112>>>>>>>        Function_Return iNumServers
68113>>>>>>>        
68113>>>>>>>    End_Function
68114>>>>>>>    
68114>>>>>>>    //   Enumerate the available SQL Server database servers
68114>>>>>>>    //   This function will return all SQL Server instances on the network.
68114>>>>>>>    //   This may take a long time.
68114>>>>>>>    //   To enumerate only local SQL Server instances use EnumerateServersLocal
68114>>>>>>>    Function EnumerateServers Returns Integer
68116>>>>>>>        
68116>>>>>>>        Integer iNumServers
68116>>>>>>>        Integer iNetworkLocal
68116>>>>>>>        
68116>>>>>>>        Move 0 to iNetworkLocal // 0 = enumerate network servers
68117>>>>>>>        
68117>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
68118>>>>>>>        
68118>>>>>>>        Function_Return iNumServers
68119>>>>>>>        
68119>>>>>>>    End_Function
68120>>>>>>>    
68120>>>>>>>    
68120>>>>>>>    //   Enumerate the available SQL Server database servers
68120>>>>>>>    //   This function will return only return SQL Server instance on the local machine
68120>>>>>>>    //   To enumerate all SQL Server instances in a network use EnumerateServers
68120>>>>>>>    Function EnumerateServersLocal Returns Integer
68122>>>>>>>        
68122>>>>>>>        Integer iNumServers
68122>>>>>>>        Integer iNetworkLocal
68122>>>>>>>        
68122>>>>>>>        Move 1 to iNetworkLocal // 1 = enumerate local servers
68123>>>>>>>        
68123>>>>>>>        Get EnumerateServersNetworkOrLocal iNetworkLocal to iNumServers
68124>>>>>>>        
68124>>>>>>>        Function_Return iNumServers
68125>>>>>>>        
68125>>>>>>>    End_Function
68126>>>>>>>    
68126>>>>>>>    
68126>>>>>>>    
68126>>>>>>>    //   Enumerate database in a given server.
68126>>>>>>>    Function EnumerateDatabases String sServer String sUser String sPassWord Returns Integer
68128>>>>>>>        Integer hoSQL
68128>>>>>>>        String  sConnect
68128>>>>>>>        String  sDatabase
68128>>>>>>>        Integer hdbc
68128>>>>>>>        Integer hstmt
68128>>>>>>>        Integer iFetchResult
68128>>>>>>>        
68128>>>>>>>        If (Num_Arguments < 3) ;            Move "" to sPassWord
68131>>>>>>>        If (Num_Arguments < 2) ;            Move "" to sUser
68134>>>>>>>        
68134>>>>>>>        If (sUser <> "") ;            Move ("SERVER=" + Trim(sServer) + ";UID=" + Trim(sUser) + ";PWD=" + Trim(sPassword) + ";") to sConnect
68137>>>>>>>        Else ;            Move ("SERVER=" + Trim(sServer) + ";Trusted_Connection=yes") to sConnect
68139>>>>>>>        
68139>>>>>>>        Object oEnumDBSQLmanager is a cSQLHandleManager
68141>>>>>>>            Move Current_Object to hoSQL
68142>>>>>>>        End_Object
68143>>>>>>>        
68143>>>>>>>        If (hoSQL <> 0) Begin
68145>>>>>>>            Get SQLConnect of hoSQL "MSSQLDRV" sConnect to hdbc
68146>>>>>>>            If (hdbc <> 0) Begin
68148>>>>>>>                Get SQLOpen of hdbc to hstmt
68149>>>>>>>                If (hstmt <> 0) Begin
68151>>>>>>>                    //   We could do a direct select on the sysdatabases table but we use
68151>>>>>>>                    //   the stored procedure sp_database instead. SQL Server recommends this
68151>>>>>>>                    //   approach in case meta data might change, the stored procedure will
68151>>>>>>>                    //   stay the same.
68151>>>>>>>                    Send SQLSetProcedureName to hstmt "sp_databases"
68152>>>>>>>                    Send SQLCall to hstmt
68153>>>>>>>                    Repeat
68153>>>>>>>>
68153>>>>>>>                        Get SQLFetch of hstmt to iFetchResult
68154>>>>>>>                        If (iFetchResult <> 0) Begin
68156>>>>>>>                            Get SQLColumnValue of hstmt 1 to sDatabase
68157>>>>>>>                            Set Value  (Item_Count(Current_Object)) to sDatabase
68158>>>>>>>                        End
68158>>>>>>>>
68158>>>>>>>                    Until (iFetchResult = 0)
68160>>>>>>>                    
68160>>>>>>>                    Send SQLClose to hstmt
68161>>>>>>>                End
68161>>>>>>>>
68161>>>>>>>                Send SQLDisconnect to hdbc
68162>>>>>>>            End
68162>>>>>>>>
68162>>>>>>>        End
68162>>>>>>>>
68162>>>>>>>        Send Destroy_Object to hoSQL
68163>>>>>>>        
68163>>>>>>>        Function_Return (Item_Count(Current_Object))
68164>>>>>>>    End_Function
68165>>>>>>>    
68165>>>>>>>    
68165>>>>>>>    Function SqlServerClientVersionName Integer iClientVersion  Returns String
68167>>>>>>>        
68167>>>>>>>        String  sSqlServerClientVersionName
68167>>>>>>>        
68167>>>>>>>        
68167>>>>>>>        Case Begin
68167>>>>>>>            
68167>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
68169>>>>>>>                Move SQLSERVER2017CLIENTNAME to sSqlServerClientVersionName
68170>>>>>>>                Case Break
68171>>>>>>>                
68171>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
68174>>>>>>>                Move SQLSERVER2016CLIENTNAME to sSqlServerClientVersionName
68175>>>>>>>                Case Break
68176>>>>>>>            
68176>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
68179>>>>>>>                Move SQLSERVER2014CLIENTNAME to sSqlServerClientVersionName
68180>>>>>>>                Case Break
68181>>>>>>>            
68181>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
68184>>>>>>>                Move SQLSERVER2012CLIENTNAME to sSqlServerClientVersionName
68185>>>>>>>                Case Break
68186>>>>>>>            
68186>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
68189>>>>>>>                Move SQLSERVER2008CLIENTNAME to sSqlServerClientVersionName
68190>>>>>>>                Case Break
68191>>>>>>>            
68191>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
68194>>>>>>>                Move SQLSERVER2005CLIENTNAME to sSqlServerClientVersionName
68195>>>>>>>                Case Break
68196>>>>>>>            
68196>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
68199>>>>>>>                Move SQLSERVER2000CLIENTNAME to sSqlServerClientVersionName
68200>>>>>>>                Case Break
68201>>>>>>>            
68201>>>>>>>            Case Else
68201>>>>>>>                Move SQLSERVERUNKNOWNCLIENTNAME to sSqlServerClientVersionName
68202>>>>>>>                
68202>>>>>>>        Case End
68202>>>>>>>        
68202>>>>>>>        
68202>>>>>>>        Function_Return sSqlServerClientVersionName
68203>>>>>>>        
68203>>>>>>>    End_Function
68204>>>>>>>
68204>>>>>>>
68204>>>>>>>    Function SqlServerClientDriverName Integer iClientVersion  Returns String
68206>>>>>>>        
68206>>>>>>>        String  sSqlServerClientDriverName
68206>>>>>>>        
68206>>>>>>>        Case Begin
68206>>>>>>>            
68206>>>>>>>            Case (iClientVersion = SQLSERVER2017CLIENT)
68208>>>>>>>                Move SQLSERVER2017DRVRSTR to sSqlServerClientDriverName
68209>>>>>>>                Case Break
68210>>>>>>>                
68210>>>>>>>            Case (iClientVersion = SQLSERVER2016CLIENT)
68213>>>>>>>                Move SQLSERVER2016DRVRSTR to sSqlServerClientDriverName
68214>>>>>>>                Case Break
68215>>>>>>>            
68215>>>>>>>            Case (iClientVersion = SQLSERVER2014CLIENT)
68218>>>>>>>                Move SQLSERVER2014DRVRSTR to sSqlServerClientDriverName
68219>>>>>>>                Case Break
68220>>>>>>>            
68220>>>>>>>            Case (iClientVersion = SQLSERVER2012CLIENT)
68223>>>>>>>                Move SQLSERVER2012DRVRSTR to sSqlServerClientDriverName
68224>>>>>>>                Case Break
68225>>>>>>>            
68225>>>>>>>            Case (iClientVersion = SQLSERVER2008CLIENT)
68228>>>>>>>                Move SQLSERVER2008DRVRSTR to sSqlServerClientDriverName
68229>>>>>>>                Case Break
68230>>>>>>>            
68230>>>>>>>            Case (iClientVersion = SQLSERVER2005CLIENT)
68233>>>>>>>                Move SQLSERVER2005DRVRSTR to sSqlServerClientDriverName
68234>>>>>>>                Case Break
68235>>>>>>>            
68235>>>>>>>            Case (iClientVersion = SQLSERVER2000CLIENT)
68238>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
68239>>>>>>>                Case Break
68240>>>>>>>            
68240>>>>>>>            Case Else
68240>>>>>>>                Move SQLSERVER2000DRVRSTR to sSqlServerClientDriverName
68241>>>>>>>                
68241>>>>>>>        Case End
68241>>>>>>>        
68241>>>>>>>        
68241>>>>>>>        Function_Return sSqlServerClientDriverName
68242>>>>>>>        
68242>>>>>>>    End_Function
68243>>>>>>>    
68243>>>>>>>    
68243>>>>>>>End_Class
68244>>>>>>>
68244>>>>>>>
68244>>>>>
68244>>>>>
68244>>>>>External_Function WNetGetUser "WNetGetUserA" MPR.DLL Pointer lpName Pointer lpUser_Name Pointer lpLength Returns DWord
68245>>>>>
68245>>>>>Register_Function phoWorkspace Returns Handle
68245>>>>>Register_Function Help_filename Returns String
68245>>>>>Register_Function GetHelpFile Returns String
68245>>>>>Register_Function pbEnterKeyAsTabKey Returns Boolean
68245>>>>>
68245>>>>>//    This function reads the current username Of windows and returns that
68245>>>>>//    name or an text unknown user
68245>>>>>Function Network_User_Name for cDesktop Returns String
68247>>>>>    String sName
68247>>>>>    Integer iRetval iLength
68247>>>>>    
68247>>>>>    Move 0 to iLength
68248>>>>>    Move (WNetGetUser (0, 0, AddressOf (iLength))) to iRetval
68249>>>>>    Move (ZeroString(iLength)) to sName
68250>>>>>    Move (WNetGetUser (0, AddressOf (sName), AddressOf (iLength))) to iRetval
68251>>>>>    
68251>>>>>    If (iRetval = NO_ERROR) Begin
68253>>>>>        Function_Return (CString (sName))
68254>>>>>    End
68254>>>>>>
68254>>>>>    
68254>>>>>    Function_Return "User Unknown"
68255>>>>>End_Function
68256>>>>>
68256>>>>>External_Function GlobalMemoryStatus "GlobalMemoryStatus" Kernel32.Dll Pointer lpsMemoryStatus Returns Integer
68257>>>>>
68257>>>>>External_Function GlobalMemoryStatusEx "GlobalMemoryStatusEx" Kernel32.Dll Pointer lpMemoryStatus Returns Integer
68258>>>>>
68258>>>>>Class SysinfoDisplay is a cTextEdit
68259>>>>>    Procedure Construct_Object
68261>>>>>        Forward Send Construct_Object
68263>>>>>        
68263>>>>>        Set Location to 6 6
68264>>>>>        Set Size to 110 255
68265>>>>>        Set Read_Only_State to True
68266>>>>>        Set pbWrap to False
68267>>>>>    End_Procedure
68268>>>>>    
68268>>>>>    //    This method will show the name Of the current directory in the system
68268>>>>>    //    information box
68268>>>>>    Procedure Show_Current_Directory
68270>>>>>        String sDir
68270>>>>>        
68270>>>>>        Get_Current_Directory to sDir
68271>>>>>        
68271>>>>>        Send AppendTextLn (SFormat (C_$CurrentDirectory, sDir))
68272>>>>>    End_Procedure
68273>>>>>    
68273>>>>>    Procedure Show_Windows_Directory
68275>>>>>        String sWindir
68275>>>>>        
68275>>>>>        Get_Windows_Directory to sWindir
68276>>>>>        
68276>>>>>        Send AppendTextLn (SFormat (C_$WindowsDirectory, sWindir))
68277>>>>>    End_Procedure
68278>>>>>    
68278>>>>>    Procedure Show_Current_User
68280>>>>>        Send AppendTextLn (SFormat (C_$NetworkUserName, Network_User_Name (Self)))
68281>>>>>    End_Procedure
68282>>>>>    
68282>>>>>    Procedure Show_Number_Format
68284>>>>>        Integer iFormat
68284>>>>>        String sFormatText
68284>>>>>        
68284>>>>>        Get_Attribute DF_THOUSANDS_SEPARATOR to iFormat
68287>>>>>        Move (Character (iFormat)) to sFormatText
68288>>>>>        Send AppendTextLn (SFormat (C_$ThousandsSeparator, sFormatText, iFormat))
68289>>>>>        
68289>>>>>        Get_Attribute DF_DECIMAL_SEPARATOR to iFormat
68292>>>>>        Move (Character (iFormat)) to sFormatText
68293>>>>>        Send AppendTextLn (SFormat (C_$DecimalSeparator, sFormatText))
68294>>>>>    End_Procedure
68295>>>>>    
68295>>>>>    Procedure Show_Filelist_Name
68297>>>>>        String sFilename
68297>>>>>        
68297>>>>>        Get_Attribute DF_FILELIST_NAME to sFilename
68300>>>>>        
68300>>>>>        Send AppendTextLn (SFormat (C_$CurrentFilelist, sFilename))
68301>>>>>        Send AppendTextLn ""
68302>>>>>    End_Procedure
68303>>>>>    
68303>>>>>    Procedure Show_Lock_Delay
68305>>>>>        Integer iLockdelay
68305>>>>>        
68305>>>>>        Get_Attribute DF_LOCK_DELAY to iLockdelay
68308>>>>>        
68308>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingDelay, iLockDelay))
68309>>>>>    End_Procedure
68310>>>>>    
68310>>>>>    Procedure Show_Lock_Timeout
68312>>>>>        Integer iLockTimeout
68312>>>>>        
68312>>>>>        Get_Attribute DF_LOCK_TIMEOUT to iLockTimeout
68315>>>>>        
68315>>>>>        Send AppendTextLn (SFormat (C_$DatabaseLockingTimeout, iLockTimeOut))
68316>>>>>    End_Procedure
68317>>>>>    
68317>>>>>    Procedure Show_Screen_Size
68319>>>>>        Integer iYscreensize iXscreensize
68319>>>>>        
68319>>>>>        Move (GetSystemMetrics (SM_CXSCREEN)) to iXscreensize
68320>>>>>        Move (GetSystemMetrics (SM_CYSCREEN)) to iYscreensize
68321>>>>>        
68321>>>>>        Send AppendTextLn (SFormat (C_$VideoResolution, iXscreensize, iYscreensize))
68322>>>>>    End_Procedure
68323>>>>>    
68323>>>>>    Procedure Show_Page_Size
68325>>>>>        Send AppendTextLn (SFormat (C_$PageEndFormFeed, Pageend, Pagefeed))
68326>>>>>    End_Procedure
68327>>>>>    
68327>>>>>    Procedure Show_Date
68329>>>>>        Date dToday
68329>>>>>        
68329>>>>>        Move (CurrentDateTime()) to  dToday
68330>>>>>        
68330>>>>>        Send AppendTextLn (SFormat (C_$CurrentSystemDate, String (dToday)))
68331>>>>>    End_Procedure
68332>>>>>    
68332>>>>>    Procedure Show_Date_Format
68334>>>>>        Integer iDateFormat
68334>>>>>        String sDateFormat
68334>>>>>        
68334>>>>>        Get_Attribute DF_DATE_FORMAT to iDateFormat
68337>>>>>        Case Begin
68337>>>>>            Case (iDateFormat = DF_DATE_USA)
68339>>>>>                Move C_$USA to sDateFormat
68340>>>>>                Case Break
68341>>>>>            Case (iDateFormat = DF_DATE_EUROPEAN)
68344>>>>>                Move C_$European to sDateFormat
68345>>>>>                Case Break
68346>>>>>            Case (iDateFormat = DF_DATE_MILITARY)
68349>>>>>                Move C_$Military to sDateFormat
68350>>>>>                Case Break
68351>>>>>            Case Else
68351>>>>>                Move C_$UnknownDateType to sDateFormat
68352>>>>>                Case Break
68353>>>>>        Case End
68353>>>>>        
68353>>>>>        Send AppendTextLn (SFormat (C_$DateFormat, sDateformat))
68354>>>>>    End_Procedure
68355>>>>>    
68355>>>>>    Procedure Show_Systemresources
68357>>>>>        tWinMemoryStatusEx MemoryStatusInfo
68357>>>>>        tWinMemoryStatusEx MemoryStatusInfo
68357>>>>>        Integer iRetval
68357>>>>>        
68357>>>>>        Move (SizeOfType (tWinMemoryStatusEx)) to MemoryStatusInfo.dwLength
68358>>>>>        Move (GlobalMemoryStatusEx (AddressOf (MemoryStatusInfo))) to iRetval
68359>>>>>        If (iRetval = 0) Begin
68361>>>>>            Move (ShowLastError ()) to iRetval
68362>>>>>        End
68362>>>>>>
68362>>>>>        
68362>>>>>        Send AppendTextLn (SFormat (C_$AvailableMemory, MemoryStatusInfo.ullTotalPhys))
68363>>>>>        Send AppendTextLn (SFormat (C_$MemoryUtilization, MemoryStatusInfo.dwMemoryLoad))
68364>>>>>        Send AppendTextLn (SFormat (C_$AvailablePhysicalMemory, Integer ( Real (MemoryStatusInfo.ullAvailPhys) / Real (MemoryStatusInfo.ullTotalPhys) * 100.0)))
68365>>>>>        Send AppendTextLn (SFormat (C_$AvailablePagefileSpace, Integer ( Real (MemoryStatusInfo.ullAvailPageFile) / Real (MemoryStatusInfo.ullTotalPageFile) * 100.0)))
68366>>>>>        Send AppendTextLn (SFormat (C_$AvailableVirtualMemory, Integer ( Real (MemoryStatusInfo.ullAvailVirtual) / Real (MemoryStatusInfo.ullTotalVirtual) * 100.0)))
68367>>>>>    End_Procedure
68368>>>>>    
68368>>>>>    Procedure Show_Registration
68370>>>>>        String sRegName
68370>>>>>        Integer iSN iMaxUsers
68370>>>>>        
68370>>>>>        Registration sRegName iSN
68371>>>>>>
68371>>>>>        
68371>>>>>        Get_Licensed_Max_Users to iMaxUsers
68372>>>>>        
68372>>>>>        Send AppendTextLn ""
68373>>>>>        Send AppendTextLn (SFormat (C_$Serial, iSN))
68374>>>>>        Send AppendTextLn (SFormat (C_$RegName, sRegName))
68375>>>>>        Send AppendTextLn (SFormat (C_$MaxNumUsers, iMaxUsers))
68376>>>>>    End_Procedure
68377>>>>>    
68377>>>>>    // If workspaces are used, we will send the message EnumerateWorkspaceData
68377>>>>>    // To the workspace object passing the an object and message To send back
68377>>>>>    // To this object. It is expected that the workspace object will send this
68377>>>>>    // message for every line Of information it wants displayed (passing the
68377>>>>>    // information To be displayed
68377>>>>>    Register_Procedure EnumerateWorkspaceData Handle hObjId Handle hmMessId
68377>>>>>    
68377>>>>>    Procedure Show_ServicePack
68379>>>>>        String sKey sVersionDescription sVersion
68379>>>>>        Handle hoRegistry
68379>>>>>        Boolean bExists bOpened
68379>>>>>        
68379>>>>>        Get Create (RefClass (cRegistry)) to hoRegistry
68380>>>>>        Set phRootKey of hoRegistry to HKEY_LOCAL_MACHINE
68381>>>>>        Set pfAccessRights of hoRegistry to KEY_READ
68382>>>>>        
68382>>>>>        Move C_DFVersionRegistryRoot to sKey
68383>>>>>        Get KeyExists of hoRegistry sKey to bExists
68384>>>>>        If (bExists) Begin
68386>>>>>            Get OpenKey of hoRegistry sKey to bOpened
68387>>>>>            If (bOpened) Begin
68389>>>>>                Get ValueExists of hoRegistry "CurrentVersionDescription" to bExists
68390>>>>>                If (bExists) Begin
68392>>>>>                    Get ReadString of hoRegistry "CurrentVersionDescription" to sVersionDescription
68393>>>>>                End
68393>>>>>>
68393>>>>>                
68393>>>>>                Get ValueExists of hoRegistry "CurrentVersion" to bExists
68394>>>>>                If (bExists) Begin
68396>>>>>                    Get ReadString of hoRegistry "CurrentVersion" to sVersion
68397>>>>>                End
68397>>>>>>
68397>>>>>                Send CloseKey of hoRegistry
68398>>>>>            End
68398>>>>>>
68398>>>>>        End
68398>>>>>>
68398>>>>>        Send Destroy of hoRegistry
68399>>>>>        
68399>>>>>        If (sVersionDescription <> "") Begin
68401>>>>>            Send AppendTextLn (sVersionDescription * "-" * sVersion)
68402>>>>>            Send AppendTextLn ""
68403>>>>>        End
68403>>>>>>
68403>>>>>    End_Procedure
68404>>>>>    
68404>>>>>    
68404>>>>>    Procedure Show_WorkspaceInformation
68406>>>>>        Integer hoWorkspace
68406>>>>>        
68406>>>>>        If (ghoApplication <> 0) Begin
68408>>>>>            Get phoWorkspace of ghoApplication to hoWorkspace
68409>>>>>            If (hoWorkspace <> 0) Begin
68411>>>>>                Send EnumerateWorkspaceData of hoWorkspace Self (Refproc (AppendTextLn))
68412>>>>>                Send AppendTextLn ""
68413>>>>>            End
68413>>>>>>
68413>>>>>        End
68413>>>>>>
68413>>>>>    End_Procedure
68414>>>>>    
68414>>>>>    // If connection ids are used, we will send the message EnumerateConnections
68414>>>>>    // to the connection manager object passing the an object and message to send
68414>>>>>    // back to this object. It is expected that the connection manager object will
68414>>>>>    // send this message for every line Of information it wants displayed (passing
68414>>>>>    // the information To be displayed
68414>>>>>    Register_Procedure EnumerateConnections Integer hObjId Integer hmMessId
68414>>>>>    
68414>>>>>    Procedure Show_ConnectionIdInformation
68416>>>>>        If (ghoConnection > 0) Begin
68418>>>>>            Send AppendTextLn ""
68419>>>>>            Send EnumerateConnections of ghoConnection Self (RefProc(AppendTextLn))
68420>>>>>        End
68420>>>>>>
68420>>>>>    End_Procedure
68421>>>>>    
68421>>>>>    Function VersionStr Integer iVer Integer iRev Integer iBld Returns String
68423>>>>>        Function_Return (String (iVer) - "." - String (iRev) - "." - String (iBld))
68424>>>>>    End_Function
68425>>>>>    
68425>>>>>    Procedure Show_Versions
68427>>>>>        Integer iVersion iRevision iBuild
68427>>>>>        
68427>>>>>        Version_Information iVersion iRevision iBuild
68429>>>>>        
68429>>>>>        Send AppendTextLn (SFormat (C_$RuntimeVersion, VersionStr(Self,iVersion,iRevision,iBuild) ))
68430>>>>>        Send AppendTextLn (SFormat (C_$PackageVersion, VersionStr(Self,PKG_VERSION, PKG_REVISION, PKG_BUILD) ))
68431>>>>>        Send AppendTextLn (SFormat (C_$FMACVersion, VersionStr(Self,FMAC_VERSION, FMAC_REVISION, FMAC_BUILD) ))
68432>>>>>    End_Procedure
68433>>>>>    
68433>>>>>    Function CKRevisionNumber String sDriverID Returns String
68435>>>>>        Handle hoCLIHandler
68435>>>>>        Handle hoDFBtrDrvHandler
68435>>>>>        String sCKRevision
68435>>>>>        
68435>>>>>        
68435>>>>>        If (sDriverID = "MSSQLDRV" or sDriverID = "ODBC_DRV" or sDriverID = "DB2_DRV") Begin
68437>>>>>            Get Create (RefClass(cCLIHandler)) to hoCLIHandler
68438>>>>>            Set psDriverID of hoCLIHandler to sDriverID
68439>>>>>            Move (CKRevision(hoCLIHandler)) to sCKRevision
68440>>>>>            Send Destroy of hoCLIHandler
68441>>>>>        End
68441>>>>>>
68441>>>>>        Else Begin
68442>>>>>            If (sDriverID = "DFBTRDRV") Begin
68444>>>>>                Get Create (RefClass(cDFBtrDrvHandler)) to hoDFBtrDrvHandler
68445>>>>>                Set psDriverID of hoDFBtrDrvHandler to sDriverID
68446>>>>>                Move (CKRevision(hoDFBtrDrvHandler)) to sCKRevision
68447>>>>>                Send Destroy of hoDFBtrDrvHandler
68448>>>>>            End
68448>>>>>>
68448>>>>>        End
68448>>>>>>
68448>>>>>        
68448>>>>>        Function_Return sCKRevision
68449>>>>>    End_Function
68450>>>>>    
68450>>>>>    
68450>>>>>    Function IsDataAccessCK String sDriverID Returns Boolean
68452>>>>>        
68452>>>>>        If (sDriverID = "DATAFLEX") Begin
68454>>>>>            Function_Return False
68455>>>>>        End
68455>>>>>>
68455>>>>>        
68455>>>>>        Function_Return (sDriverID = "MSSQLDRV" or sDriverID = "ODBC_DRV" or sDriverID = "DB2_DRV" or sDriverID = "DFBTRDRV")
68456>>>>>    End_Function
68457>>>>>    
68457>>>>>    
68457>>>>>    Procedure Show_Drivers
68459>>>>>        String sCurrentDriver sRevNumber
68459>>>>>        String sLoadedDrivers sClientDriver
68459>>>>>        Integer iNumberOfDrivers iCount iClientVersion iMSSQLIndex
68459>>>>>        Boolean bOK
68459>>>>>        Handle hoMsqlDrv
68459>>>>>        
68459>>>>>        Move "" to sLoadedDrivers
68460>>>>>        Get_Attribute DF_NUMBER_DRIVERS to iNumberOfDrivers
68463>>>>>        For iCount from 1 to iNumberOfDrivers
68469>>>>>>
68469>>>>>            Get_Attribute DF_DRIVER_NAME of iCount to sCurrentDriver
68472>>>>>            If (sLoadedDrivers <> "") Begin
68474>>>>>                Move (Append (sLoadedDrivers, ", ")) to sLoadedDrivers
68475>>>>>            End
68475>>>>>>
68475>>>>>            Get IsDataAccessCK sCurrentDriver to bOK
68476>>>>>            If (bOK) Begin
68478>>>>>                If (sCurrentDriver = "MSSQLDRV") Begin
68480>>>>>                    Move iCount to iMSSQLIndex
68481>>>>>                End
68481>>>>>>
68481>>>>>                Get CKRevisionNumber sCurrentDriver to sRevNumber
68482>>>>>                // if mssqldrv, show the client number
68482>>>>>                Move (sCurrentDriver * "(" + sRevNumber + ")") to sCurrentDriver
68483>>>>>            End
68483>>>>>>
68483>>>>>            Move (Append (sLoadedDrivers, sCurrentDriver)) to sLoadedDrivers
68484>>>>>        Loop
68485>>>>>>
68485>>>>>        Send AppendTextLn (SFormat (C_$DatabaseDriver, sLoadedDrivers))
68486>>>>>        If (iMSSQLIndex>0) Begin
68488>>>>>            Get_Attribute DF_DRIVER_SQLSERVER_CLIENT_VERSION of iMSSQLIndex to iClientVersion
68491>>>>>            Get Create (RefClass(cMSSQLHandler)) to hoMsqlDrv
68492>>>>>            Get SqlServerClientVersionName of hoMsqlDrv iClientVersion to sClientDriver
68493>>>>>            Send Destroy of hoMsqlDrv
68494>>>>>            Send AppendTextLn (SFormat("MSSQLDRV Client Version: %1", sClientDriver))
68495>>>>>        End
68495>>>>>>
68495>>>>>    End_Procedure
68496>>>>>    
68496>>>>>    Procedure Show_HelpFile
68498>>>>>        String sHelpFile
68498>>>>>        Integer eHelpType
68498>>>>>        
68498>>>>>        If (ghoApplication <> 0) Begin
68500>>>>>            Get peHelpType of ghoApplication to eHelpType
68501>>>>>            If (eHelpType = htHtmlHelp and ghoHtmlHelp) Begin
68503>>>>>                Get GetHelpFile of ghoHtmlHelp to sHelpFile
68504>>>>>            End
68504>>>>>>
68504>>>>>            Else If (eHelpType = htWinHelp and Help_object_id) Begin
68507>>>>>                Get Help_filename of Help_object_id to sHelpFile
68508>>>>>            End
68508>>>>>>
68508>>>>>            Else Begin
68509>>>>>                Move C_$ThereIsNoHelpfileDefined to sHelpFile
68510>>>>>            End
68510>>>>>>
68510>>>>>            
68510>>>>>            Send AppendTextLn ""
68511>>>>>            Send AppendTextLn (SFormat (C_$HelpFile, sHelpFile))
68512>>>>>        End
68512>>>>>>
68512>>>>>    End_Procedure
68513>>>>>    
68513>>>>>    Procedure Show_EnterAsTab
68515>>>>>        Boolean bEnterKeyAsTabKey
68515>>>>>        String sText
68515>>>>>        
68515>>>>>        If (ghoApplication <> 0) Begin
68517>>>>>            Get pbEnterKeyAsTabKey of ghoApplication to bEnterKeyAsTabKey
68518>>>>>            If (bEnterKeyAsTabKey) Begin
68520>>>>>                Move "True" to sText
68521>>>>>            End
68521>>>>>>
68521>>>>>            Else Begin
68522>>>>>                Move "False" to sText
68523>>>>>            End
68523>>>>>>
68523>>>>>            Send AppendTextLn (SFormat (C_$EnterKeyNavForward, sText))
68524>>>>>        End
68524>>>>>>
68524>>>>>    End_Procedure
68525>>>>>    
68525>>>>>    //    During activation we will remove the old information and add the newly
68525>>>>>    //    found systeminformation
68525>>>>>    Procedure Add_Focus Integer hoRoot
68527>>>>>        Forward Send Add_Focus hoRoot
68529>>>>>        
68529>>>>>        Send Delete_Data
68530>>>>>        
68530>>>>>        Set Changed_State to False
68531>>>>>        Set Read_Only_State to True
68532>>>>>        
68532>>>>>        Send Show_ServicePack
68533>>>>>        Send Show_Versions
68534>>>>>        Send Show_Drivers
68535>>>>>        If (ghoConnection <> 0) Begin
68537>>>>>            Send Show_ConnectionIdInformation
68538>>>>>        End
68538>>>>>>
68538>>>>>        Send Show_HelpFile
68539>>>>>        Send Show_Current_Directory
68540>>>>>        Send Show_Filelist_Name
68541>>>>>        If (ghoApplication <> 0) Begin
68543>>>>>            Send Show_WorkSpaceInformation // added To show WS info
68544>>>>>        End
68544>>>>>>
68544>>>>>        Send Show_Current_User
68545>>>>>        Send Show_Windows_Directory
68546>>>>>        Send Show_Screen_Size
68547>>>>>        Send Show_Page_Size
68548>>>>>        Send Show_EnterAsTab
68549>>>>>        Send Show_Number_Format
68550>>>>>        Send Show_Date_Format
68551>>>>>        Send Show_Lock_Delay
68552>>>>>        Send Show_Lock_Timeout
68553>>>>>        Send Show_Date
68554>>>>>        Send Show_Systemresources
68555>>>>>        Send Show_Registration
68556>>>>>        Send Beginning_of_Data
68557>>>>>        
68557>>>>>        Set Icon to 'default.ico'
68558>>>>>    End_Procedure
68559>>>>>End_Class
68560>>>>>
68560>>>>>Class SysInfoDialog is a ModalPanel
68561>>>>>    Procedure Construct_Object
68563>>>>>        Forward Send Construct_Object
68565>>>>>        
68565>>>>>        Set Label to C_$SystemInformation
68566>>>>>        Set Size to 140 267
68567>>>>>        Set piMinSize to 140 267
68568>>>>>        Set Locate_Mode to CENTER_ON_SCREEN
68569>>>>>        Set Border_Style to Border_Thick
68570>>>>>        
68570>>>>>        Object oSysinfoDisplay is a SysInfoDisplay
68572>>>>>            Set peAnchors to anAll
68573>>>>>        End_Object
68574>>>>>        
68574>>>>>        Object oCloseButton is a Button
68576>>>>>            Set Label to C_$Close
68577>>>>>            Set Location to 120 210
68578>>>>>            Set Message 0 to (Refproc (Close_Panel))
68579>>>>>            Set Default_State to True
68580>>>>>            Set peAnchors to anBottomRight
68581>>>>>        End_Object
68582>>>>>        
68582>>>>>        On_Key kCancel Send Close_Panel
68583>>>>>    End_Procedure
68584>>>>>End_Class
68585>>>>>
68585>>>>>Class AboutDialog is a ModalPanel
68586>>>>>    Procedure Construct_Object
68588>>>>>        String sVdfRootDir
68588>>>>>        
68588>>>>>        Forward Send Construct_Object
68590>>>>>        
68590>>>>>        Set Label to C_$About
68591>>>>>        Set Size to 89 212
68592>>>>>        Set Locate_Mode to CENTER_ON_SCREEN
68593>>>>>        
68593>>>>>        Object oSysInfoDialog is a SysInfoDialog
68595>>>>>        End_Object
68596>>>>>        
68596>>>>>        Object oBox is a Container3d
68598>>>>>            Set Border_Style to Border_StaticEdge
68599>>>>>            Set Size to 63 202
68600>>>>>            Set Location to 4 5
68601>>>>>            
68601>>>>>            Object oAboutGraphic is a BitmapContainer
68603>>>>>                Set Border_Style to Border_None
68604>>>>>                Set Bitmap_Style to Bitmap_Center
68605>>>>>                Set Size to 48 48
68606>>>>>                Set Location to 7 2
68607>>>>>            End_Object
68608>>>>>            
68608>>>>>            Object oProductName is a TextBox
68610>>>>>                Set Label to C_$ProductName
68611>>>>>                Set Size to 10 45
68612>>>>>                Set Location to 8 53
68613>>>>>            End_Object
68614>>>>>            
68614>>>>>            Object oVersion is a TextBox
68616>>>>>                Set Label to C_$Version
68617>>>>>                Set Size to 10 25
68618>>>>>                Set Location to 21 53
68619>>>>>            End_Object
68620>>>>>            
68620>>>>>            Object oCopyright is a TextBox
68622>>>>>                Set Label to C_$Copyright
68623>>>>>                Set Size to 10 31
68624>>>>>                Set Location to 34 53
68625>>>>>            End_Object
68626>>>>>            
68626>>>>>            Object oAuthor is a TextBox
68628>>>>>                Set Label to C_$Author
68629>>>>>                Set Size to 10 22
68630>>>>>                Set Location to 46 53
68631>>>>>            End_Object
68632>>>>>        End_Object
68633>>>>>        
68633>>>>>        Object oOKButton is a Button
68635>>>>>            On_Item C_$OK Send Close_Panel
68636>>>>>            Set Size to 14 50
68637>>>>>            Set Location to 71 157
68638>>>>>        End_Object
68639>>>>>        
68639>>>>>        Object oSysInfoButton is a Button
68641>>>>>            On_Item C_$SystemInfo Send Show_Sysinfo
68642>>>>>            Set Size to 14 50
68643>>>>>            Set Location to 71 101
68644>>>>>        End_Object
68645>>>>>        
68645>>>>>        On_Key Kcancel Send KeyAction of oOKButton
68646>>>>>        
68646>>>>>        Set Logo to "DacAbout.bmp"  // square bitmaps Of 42x42 work best
68647>>>>>    End_Procedure
68648>>>>>    
68648>>>>>    Procedure Set ProductName String sProductName
68650>>>>>        Set Label of oProductName to sProductName
68651>>>>>    End_Procedure
68652>>>>>    
68652>>>>>    Procedure Set Version String sVersion
68654>>>>>        Set Label of oVersion to sVersion
68655>>>>>    End_Procedure
68656>>>>>    
68656>>>>>    Procedure Set Copyright String sCopyright
68658>>>>>        Set Label of oCopyright to sCopyright
68659>>>>>    End_Procedure
68660>>>>>    
68660>>>>>    Procedure Set Author String sAuthor
68662>>>>>        Set Label of oAuthor to sAuthor
68663>>>>>    End_Procedure
68664>>>>>    
68664>>>>>    Procedure Set Logo String sLogo
68666>>>>>        // square bitmaps Of 42x42 work best
68666>>>>>        Set Bitmap of oAboutGraphic to sLogo
68667>>>>>    End_Procedure
68668>>>>>    
68668>>>>>    Procedure Show_Sysinfo
68670>>>>>        Send Popup_Modal of oSysinfoDialog
68671>>>>>    End_Procedure
68672>>>>>    
68672>>>>>    Procedure End_Construct_Object
68674>>>>>        Handle hoVersionInfo
68674>>>>>        Boolean bIncluded
68674>>>>>        Integer iMajor iMinor iRelease iBuild
68674>>>>>        String sLabel
68674>>>>>        
68674>>>>>        Get Label of oVersion to sLabel
68675>>>>>        If (sLabel = C_$VERSION) Begin
68677>>>>>            // set it To the version info Of the program, if available
68677>>>>>            If (ghoApplication <> 0) Begin
68679>>>>>                Get phoVersionInfo of ghoApplication to hoVersionInfo
68680>>>>>                If (hoVersionInfo <> 0) Begin
68682>>>>>                    Get pbIncluded of hoVersionInfo to bIncluded
68683>>>>>                    If (bIncluded) Begin
68685>>>>>                        Get piVersionMajor of hoVersionInfo to iMajor
68686>>>>>                        Get piVersionMinor of hoVersionInfo to iMinor
68687>>>>>                        Get piVersionRelease of hoVersionInfo to iRelease
68688>>>>>                        Get piVersionBuild of hoVersionInfo to iBuild
68689>>>>>                        Move (SFormat (C_$VERSION + ": %1.%2.%3.%4", iMajor, iMinor, iRelease, iBuild)) to sLabel
68690>>>>>                        Set Version to sLabel
68691>>>>>                    End
68691>>>>>>
68691>>>>>                End
68691>>>>>>
68691>>>>>            End
68691>>>>>>
68691>>>>>        End
68691>>>>>>
68691>>>>>        
68691>>>>>        Forward Send End_Construct_Object
68693>>>>>    End_Procedure
68694>>>>>End_Class
68695>>>
68695>>>//  This is the default message. It is expected that you will
68695>>>//  create your own message to override this
68695>>>Procedure Activate_About
68697>>>    Send DoAbout "" "" "" "" ""
68698>>>End_Procedure
68699>>>
68699>>>//  It is expected that you will send this message (most
68699>>>//  likely from Activate_About. This creates an about object, activates it
68699>>>//  and destroys it when done. It is not exepected that you will augment this.
68699>>>Procedure DoAbout String sTitle String sVersion String sCopyRight String sAuthor String sBitmap
68701>>>    Integer hoObj hoMain
68701>>>    
68701>>>    // create object
68701>>>    Object About is an AboutDialog
68703>>>        // if no title passed use the label of the main panel
68703>>>        // (if a main panel exists).
68703>>>        If (sTitle = "") Begin
68705>>>            Get Main_Window of desktop to hoMain
68706>>>            If hoMain ;                Get Label of hoMain to sTitle
68709>>>        End
68709>>>>
68709>>>        Set productname to sTitle
68710>>>        Set version     to sVersion
68711>>>        Set copyright   to sCopyRight
68712>>>        Set author      to sAuthor
68713>>>        If (sBitmap <> '') ;            Set logo to sBitMap // square bitmaps of 42x42 work best
68716>>>        Move Self to hoObj // object Id
68717>>>    End_Object
68718>>>    Send Popup   of hoObj    // popup the about object
68719>>>    Send Destroy of hoObj // when done, it will be destroyed
68720>>>End_Procedure
68721>>>
68721>    
68721>Object oHtmlHelp is a cHtmlHelp
68723>End_Object
68724>
68724>Object oApplication is a cApplication
68726>    Set pbPreserveEnvironment to False
68727>    Set peHelpType to htHtmlHelp
68728>End_Object
68729>
68729>Object oToolTipController is a cToolTipController
68731>    Move Self to ghoToolTipController
68732>End_Object
68733>
68733>Use oEditContextMenu.pkg
Including file: oEditContextMenu.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\oEditContextMenu.pkg)
68733>>>Use cCJStandardMenuItemClasses.pkg
68733>>>
68733>>>Object oEditContextMenu is a cCJContextMenu
68735>>>    
68735>>>    Move Self to Default_Form_Floating_Menu_ID
68736>>>    
68736>>>    Object oUndoMenuItem is a cCJUndoMenuItem
68738>>>    End_Object
68739>>>    
68739>>>    Object oCutMenuItem is a cCJCutMenuItem
68741>>>        Set pbControlBeginGroup to True
68742>>>    End_Object
68743>>>    
68743>>>    Object oCopyMenuItem is a cCJCopyMenuItem
68745>>>    End_Object
68746>>>
68746>>>    Object oPasteMenuItem is a cCJPasteMenuItem
68748>>>    End_Object
68749>>>
68749>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
68751>>>    End_Object
68752>>>
68752>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
68754>>>        Set pbControlBeginGroup to True
68755>>>    End_Object
68756>>>
68756>>>End_Object
68757>>>
68757>Use oDEOEditContextMenu17.pkg
Including file: oDEOEditContextMenu17.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\oDEOEditContextMenu17.pkg)
68757>>>Use Windows.pkg
68757>>>Use cCJStandardMenuItemClasses.pkg
68757>>>Use cCJDeoMenuItemClasses.pkg
68757>>>
68757>>>
68757>>>Object oDEOEditContextMenu17 is a cCJContextMenu
68759>>>    
68759>>>    Move Self to Default_dbFloating_Menu_ID
68760>>>    
68760>>>    Object oUndoMenuItem is a cCJUndoMenuItem
68762>>>    End_Object
68763>>>    
68763>>>    Object oCutMenuItem is a cCJCutMenuItem
68765>>>        Set pbControlBeginGroup to True
68766>>>    End_Object
68767>>>    
68767>>>    Object oCopyMenuItem is a cCJCopyMenuItem
68769>>>    End_Object
68770>>>
68770>>>    Object oPasteMenuItem is a cCJPasteMenuItem
68772>>>    End_Object
68773>>>
68773>>>    Object oDeleteItem is a cCJDeleteEditMenuItem
68775>>>    End_Object
68776>>>
68776>>>    Object oSelectAllMenuItem is a cCJSelectAllMenuItem
68778>>>        Set pbControlBeginGroup to True
68779>>>    End_Object
68780>>>
68780>>>    Object oPromptMenuItem is a cCJPromptMenuItem
68782>>>        Set pbControlBeginGroup to True
68783>>>    End_Object
68784>>>
68784>>>    Object oFindNextMenu is a cCJFindNextMenuItem
68786>>>        Set pbControlBeginGroup to True
68787>>>    End_Object
68788>>>
68788>>>    Object oFindPreviousMenu is a cCJFindPreviousMenuItem
68790>>>    End_Object
68791>>>
68791>>>    Object oClearMenuItem is a cCJClearMenuItem
68793>>>        Set pbControlBeginGroup to True
68794>>>    End_Object
68795>>>
68795>>>    Object oClearAllMenu is a cCJClearAllMenuItem
68797>>>    End_Object
68798>>>
68798>>>    Object oSaveMenu is a cCJSaveMenuItem
68800>>>    End_Object
68801>>>    
68801>>>    Object oDeleteMenu is a cCJDeleteMenuItem
68803>>>    End_Object
68804>>>
68804>>>    Object oRememberitem is a cCJRememberFieldMenuItem
68806>>>        Set pbControlBeginGroup to True
68807>>>    End_Object
68808>>>
68808>>>    Object oRetainItem is a cCJRememberLastFieldMenuItem
68810>>>    End_Object
68811>>>
68811>>>    Object oUnRememberitem is a cCJUnRememberFieldMenuItem
68813>>>    End_Object
68814>>>
68814>>>    Object oCJClearAllDynamicDefaults is a cCJUnRememberFieldAllMenuItem
68816>>>    End_Object
68817>>>
68817>>>End_Object
68818>
68818>Object oMain is a Panel
68820>    Set Icon to "favicon.ico"
68821>
68821>    Property Handle phoViewMenu 0
68823>    Property Handle phoReportMenu 0
68825>
68825>    Set Label To "Generate structs from JSON"
68826>    Set Location to 4 3
68827>    Set Size to 300 450
68828>
68828>    Object oCommandBarSystem is a cCJCommandBarSystem
68830>        Set pbTimerUpdate to True
68831>
68831>        Procedure OnCreateCommandBars
68834>            Handle hoOptions
68834>            Get OptionsObject to hoOptions
68835>            Forward Send OnCreateCommandBars
68837>        End_Procedure
68838>
68838>        Object oMenuBar is a cCJMenuBar
68840>
68840>            Object oFileMenu is a cCJMenuItem
68842>                Set peControlType to xtpControlPopup          
68843>                Set psCaption to "&File"
68844>                Set psCategory to "Menus"
68845>
68845>
68845>                Object oExitMenu is a cCJExitMenuItem
68847>                    Set pbControlBeginGroup to True
68848>                End_Object
68849>
68849>            End_Object
68850>
68850>            Object oViewMenu is a cCJMenuItem
68852>                Set peControlType to xtpControlPopup
68853>                Set psCaption to "&View"
68854>                Set psToolTip to "View"
68855>                Set psDescription to "Available Views"
68856>
68856>                Object oGeneratorMenuItem is a cCJMenuItem
68858>                    Set psCaption to "Generator"
68859>                    Set psTooltip to "Generator"
68860>                
68860>                    Procedure OnExecute Variant vCommandBarControl
68863>                        Handle hoClient
68863>                        Get Client_Id to hoClient
68864>                        Send Activate_oGenerator of hoClient
68865>                    End_Procedure
68866>                End_Object
68867>
68867>                Delegate Set phoViewMenu to Self
68869>            End_Object
68870>
68870>
68870>            Object oWindowMenu is a cCJMDIWindowsMenuItem
68872>                Set peControlType to xtpControlPopup      
68873>                Set psCaption to "&Window"
68874>                Set psToolTip to "Window"
68875>                Set psDescription to "Display Current Views and set other display options."    
68876>
68876>                // These are the static windows items. More will be created in onPopupInit
68876>                Object oDisplayOptionsMenu is a cCJMenuItem
68878>                    Set peControlType to xtpControlPopup              
68879>                    Set psCaption to "&Display Options"
68880>                    Set psToolTip to "Display Options"
68881>                    Set psDescription to "Set display options"
68882>
68882>                    Object oStatusbarMenu is a cCJStatusbarMenuItem
68884>                    End_Object
68885>
68885>                    Object oAutoArrangeIconsMenu is a cCJAutoArrangeIconsMenuItem
68887>                    End_Object
68888>
68888>                    Object oRestoreMenusMenu is a cCJRestoreMenusMenuItem
68890>                        Set pbControlBeginGroup to True
68891>                    End_Object
68892>
68892>                End_Object
68893>
68893>                Object oCascadeMenu is a cCJCascadeMenuItem
68895>                    Set pbControlBeginGroup to True
68896>                End_Object
68897>
68897>                Object oHorizTile is a cCJTileHorizontally
68899>                End_Object
68900>
68900>                Object oVertTile is a cCJTileVertically
68902>                End_Object
68903>
68903>                Object oMinimizeMenuItem is a cCJMinimizeWindowsMenuItem
68905>                    Set pbControlBeginGroup to True
68906>                End_Object
68907>
68907>                Object oRestoreMenuItem is a cCJRestoreWindowsMenuItem
68909>                End_Object
68910>
68910>                Object oArrangeIconsMenuItem is a cCJAutoArrangeIconsMenuItem
68912>                    Set pbControlBeginGroup to True
68913>                End_Object
68914>
68914>            End_Object
68915>
68915>            Object oHelpMenu is a cCJMenuItem
68917>                Set peControlType to xtpControlPopup    
68918>                Set psCaption to "&Help"
68919>                Set psDescription to "Access Information for learning and using this DataFlex application."
68920>                Set psToolTip to "Help"
68921>
68921>                Object oHelpMenuItem is a cCJHelpMenuItem 
68923>                End_Object
68924>
68924>                Object oAboutMenuItem is a cCJAboutMenuItem
68926>                End_Object
68927>
68927>            End_Object
68928>
68928>        End_Object
68929>
68929>        Object oStatusBar is a cCJStatusBar
68931>
68931>            Object oStatusPane1 is a cCJStatusBarPane
68933>                Set piID to sbpIDIdlePane
68934>                Set pbStyleStretch to True
68935>            End_Object
68936>
68936>            Object oStatusPane2 is a cCJStatusBarPane
68938>                Set phoViewPane to Self
68939>                Set pbStyleStretch to True
68940>            End_Object
68941>
68941>        End_Object
68942>
68942>    End_Object
68943>
68943>    Object oClientArea is a ClientArea
68945>
68945>//        Use Dd_debug.dg // This Provides access to dd debugger by pressing ctrl+d within any view. Good for debugging
68945>
68945>//        Use StdAbout.pkg
68945>        Use Generator.vw
Including file: Generator.vw    (C:\Projects\RESTGen191\AppSrc\Generator.vw)
68945>>>Use Windows.pkg
68945>>>Use DFClient.pkg
68945>>>Use cJsonObject.pkg
Including file: cJsonObject.pkg    (C:\Program Files (x86)\DataFlex 19.1\Pkg\cJsonObject.pkg)
68945>>>>>// cJSONObject is defined directly in fmac
68945>>>>>// We just define the constants here. They have intentionally not been moved to fmac
68945>>>>>
68945>>>>>
68945>>>>>Enum_List
68945>>>>>    Define jpWhitespace_Plain for 0
68945>>>>>    Define jpWhitespace_Spaced for 1
68945>>>>>    Define jpWhitespace_Pretty for 2
68945>>>>>End_Enum_List
68945>>>>>
68945>>>>>Enum_List
68945>>>>>    Define jsonTypeNull
68945>>>>>    Define jsonTypeBoolean
68945>>>>>    Define jsonTypeDouble
68945>>>>>    Define jsonTypeInteger
68945>>>>>    Define jsonTypeObject
68945>>>>>    Define jsonTypeArray
68945>>>>>    Define jsonTypeString
68945>>>>>End_Enum_List
68945>>>>>
68945>>>Use seq_chnl.pkg
68945>>>
68945>>>//#REPLACE BIF_USENEWUI //Version 5.0. Use the new user interface, including an edit box. This flag is equivalent to BIF_EDITBOX | BIF_NEWDIALOGSTYLE. Note  If COM is initialized through CoInitializeEx with the COINIT_MULTITHREADED flag set, SHBrowseForFolder fails if BIF_USENEWUI is passed.
68945>>>
68945>>>Struct BrowseInfo
68945>>>    Integer hwndOwner
68945>>>    Integer pidlRoot
68945>>>    String  pszDisplayName
68945>>>    String  lpszTitle
68945>>>    Integer ulFlags
68945>>>    Integer lpfn
68945>>>    Integer lParam
68945>>>    Integer iImage
68945>>>End_Struct
68945>>>
68945>>>External_Function SHBrowseForFolder "SHBrowseForFolder" Shell32.dll Pointer BrowseInfo Returns Integer
68946>>>External_Function SHGetPathFromIDList "SHGetPathFromIDList" Shell32.dll Integer pidList Integer lpBuffer Returns Integer
68947>>>
68947>>>Define C_US for (Ascii("_"))
68947>>>
68947>>>Deferred_View Activate_oGenerator for ;Object oGenerator is a dbView
68972>>>    Set Border_Style to Border_Thick
68973>>>    Set Size to 192 433
68974>>>    Set Location to 2 2
68975>>>    Set Label to "Generator"
68976>>>    
68976>>>    Property Integer  piWarnings
68978>>>    Property String   psPath
68980>>>    Property String   psAppPath
68982>>>    Property String   psOuter
68984>>>    Property Integer  piIndent
68986>>>    Property String[] pasOriginalNames
68988>>>    Property String[] pasReplacedNames
68990>>>    
68990>>>    Function UCFirst String sVal Returns String
68993>>>        Function_Return (Uppercase(Left(sVal, 1)) + Right(sVal, (Length(sVal) - 1)))
68994>>>    End_Function
68995>>>    
68995>>>    Procedure ReplaceNames Handle hoJson
68998>>>        String[]  asOriginal asReplaced asOrig asRepl
69002>>>        Integer   i j iMembs iLast iPos iType
69002>>>        UChar[]   ucaName
69003>>>        String    sName sRepl
69003>>>        Handle    hoMemb
69003>>>        
69003>>>        Get pasOriginalNames to asOriginal
69004>>>        Get pasReplacedNames to asReplaced
69005>>>        
69005>>>        If (JsonType(hoJson) = jsonTypeObject) Begin
69007>>>            Get MemberCount of hoJson to iMembs
69008>>>            Decrement iMembs
69009>>>            
69009>>>            For j from 0 to iMembs
69015>>>>
69015>>>                Get MemberNameByIndex of hoJson j to sName
69016>>>                Move sName                        to sRepl
69017>>>            
69017>>>                If (Length(sName) = 0) Begin
69019>>>                    Move 0                                  to iPos
69020>>>                End
69020>>>>
69020>>>                Else Begin
69021>>>                    Move (SearchArray(sName, asOriginal))   to iPos            
69022>>>                End
69022>>>>
69022>>>                
69022>>>                // If name has length and we don't have it already, process:
69022>>>                If (iPos = -1) Begin
69024>>>                    Move (StringToUCharArray(sName))        to ucaName
69025>>>                    Move (SizeOfArray(ucaName) - 1)         to iLast
69026>>>                    
69026>>>                    For i from 0 to iLast
69032>>>>
69032>>>        
69032>>>                        Case Begin
69032>>>                            // A digit in 1st place
69032>>>                            Case ((i = 0) and ((ucaName[i] >= 48) and (ucaName[i] <= 57)))
69034>>>                                Move C_US to ucaName[i]
69035>>>                                Case Break
69036>>>                            // Double-quote
69036>>>                            Case (ucaName[i] = 34)
69039>>>                                Move C_US to ucaName[i]
69040>>>                                Case Break
69041>>>                            // ASCII 36-47
69041>>>                            Case ((ucaName[i] >= 36) and (ucaName[i] <= 47))
69044>>>                                Move C_US to ucaName[i]
69045>>>                                Case Break
69046>>>                            // ASCII 58-64
69046>>>                            Case ((ucaName[i] >= 58) and (ucaName[i] <= 64))
69049>>>                                Move C_US to ucaName[i]
69050>>>                                Case Break
69051>>>                            // ASCII 91-94
69051>>>                            Case ((ucaName[i] >= 91) and (ucaName[i] <= 94))
69054>>>                                Move C_US to ucaName[i]
69055>>>                                Case Break
69056>>>                            // ASCII 96
69056>>>                            Case (ucaName[i] = 96)
69059>>>                                Move C_US to ucaName[i]
69060>>>                                Case Break
69061>>>                            // Greater than ASCII 123
69061>>>                            Case (ucaName[i] >= 123)
69064>>>                                Move C_US to ucaName[i]
69065>>>                                Case Break
69066>>>                        Case End
69066>>>                        
69066>>>                    Loop
69067>>>>
69067>>>                            
69067>>>                    Move (UCharArrayToString(ucaName))    to sRepl
69068>>>                End            
69068>>>>
69068>>>                            
69068>>>                
69068>>>                If (sName <> sRepl) Begin  // There have been replacements
69070>>>                    Move (SizeOfArray(asOrig))  to iPos
69071>>>                    Move sName                  to asOrig[iPos]
69072>>>                    Move sRepl                  to asRepl[iPos]
69073>>>                End
69073>>>>
69073>>>                
69073>>>            Loop
69074>>>>
69074>>>            
69074>>>            Move (SizeOfArray(asRepl) - 1) to iLast
69075>>>            
69075>>>            For i from 0 to iLast
69081>>>>
69081>>>                
69081>>>                If (HasMember(hoJson, asOrig[i])) Begin
69083>>>                    Get Member        of hoJson asOrig[i] to hoMemb
69084>>>                    Send RemoveMember of hoJson asOrig[i]
69085>>>                    Send SetMember    of hoJson asRepl[i] hoMemb
69086>>>                    Send Destroy      of hoMemb
69087>>>                End
69087>>>>
69087>>>                
69087>>>            Loop
69088>>>>
69088>>>            
69088>>>            Move (AppendArray(asOriginal, asOrig)) to asOriginal
69089>>>            Move (AppendArray(asReplaced, asRepl)) to asReplaced
69090>>>            Set pasOriginalNames to asOriginal
69091>>>            Set pasReplacedNames to asReplaced
69092>>>        End
69092>>>>
69092>>>        
69092>>>        // Now recurse down the tree
69092>>>        Get MemberCount of hoJson to iMembs
69093>>>        Decrement iMembs
69094>>>        
69094>>>        For i from 0 to iMembs
69100>>>>
69100>>>            Get MemberByIndex of hoJson i  to hoMemb
69101>>>            Get JsonType of hoMemb         to iTYpe
69102>>>            
69102>>>            If ((iType = jsonTypeObject) or (iType = jsonTypeArray)) Begin
69104>>>                Send ReplaceNames hoMemb
69105>>>            End
69105>>>>
69105>>>            
69105>>>        Loop
69106>>>>
69106>>>        
69106>>>    End_Procedure
69107>>>
69107>>>    Procedure WriteStruct Handle hoJson String sName String sParent
69110>>>        String[] asOrig asRepl
69112>>>        Integer  iChn i iLast iType iInd iArrType iMembs
69112>>>        String   sMemb sPre
69112>>>        Handle   hoMemb hoArrMemb
69112>>>                
69112>>>        Get MemberCount of hoJson to iLast
69113>>>        Decrement iLast
69114>>>        
69114>>>        For i from 0 to iLast
69120>>>>
69120>>>            Get MemberNameByIndex  of hoJson i     to sMemb
69121>>>            Get MemberJsonType     of hoJson sMemb to iType
69122>>>            
69122>>>            If (iType = jsonTypeObject) Begin
69124>>>                Get Member of hoJson sMemb to hoMemb
69125>>>                Send WriteStruct hoMemb sMemb sName
69126>>>                Send Destroy of hoMemb
69127>>>            End
69127>>>>
69127>>>            Else If (iType = jsonTypeArray) Begin
69130>>>                Get Member of hoJson sMemb to hoMemb
69131>>>
69131>>>                If (MemberCount(hoMemb)) Begin
69133>>>                    Get MemberByIndex of hoMemb 0 to hoArrMemb
69134>>>                    Get JsonType of hoArrMemb to iType
69135>>>                    
69135>>>                    If (iType = jsonTypeObject) Begin
69137>>>                        Send WriteStruct hoArrMemb sMemb sName
69138>>>                    End
69138>>>>
69138>>>    
69138>>>                End
69138>>>>
69138>>>                
69138>>>                Send Destroy of hoMemb                
69139>>>            End
69139>>>>
69139>>>            
69139>>>        Loop
69140>>>>
69140>>>        
69140>>>        Get piIndent to iInd
69141>>>        Get psOuter  to sPre
69142>>>        
69142>>>        Get Seq_New_Channel to iChn
69143>>>        Direct_Output channel iChn (psPath(Self) + "\" + sPre + UCFirst(Self, sName) + ".pkg")
69145>>>
69145>>>        Showln "Generating struct packanges for " sPre (UCFirst(Self, sName)) " in " (psPath(Self))
69151>>>
69151>>>        Writeln channel iChn "// File: " sPre (UCFirst(Self, sName)) ".pkg generated by Unicorn InterGlobal's " (Module_Name(Self)) " program, " (String(CurrentDateTime()))
69160>>>        Writeln channel iChn
69162>>>// ToDo: write initial guff
69162>>>//        Writeln channel iChn // initial guff
69162>>>        
69162>>>        //Uses:
69162>>>        Writeln channel iChn "Use cJsonObject.pkg"
69165>>>
69165>>>        Get MemberCount of hoJson to iLast
69166>>>        Decrement iLast
69167>>>        
69167>>>        For i from 0 to iLast
69173>>>>
69173>>>            Get MemberNameByIndex of hoJson i  to sMemb
69174>>>            Get MemberJsonType of hoJson sMemb to iType
69175>>>            
69175>>>            If (iType = jsonTypeObject) Begin
69177>>>                Writeln channel iChn ("Use" * psAppPath(Self) + "\" + sPre + UCFirst(Self, sMemb) + ".pkg")
69180>>>            End
69180>>>>
69180>>>            Else If (iType = jsonTypeArray) Begin
69183>>>                Get Member of hoJson sMemb to hoMemb
69184>>>                
69184>>>                If (MemberCount(hoMemb)) Begin
69186>>>                    Get MemberByIndex of hoMemb 0 to hoArrMemb
69187>>>                    Get JsonType of hoArrMemb to iType
69188>>>                    
69188>>>                    If (iType = jsonTypeObject) Begin
69190>>>                        Writeln channel iChn ("Use" * psAppPath(Self) + "\" + sPre + UCFirst(Self, sMemb) + ".pkg")
69193>>>                    End
69193>>>>
69193>>>                    
69193>>>                    Send Destroy of hoArrMemb
69194>>>                End
69194>>>>
69194>>>                    
69194>>>                Send Destroy of hoMemb
69195>>>            End
69195>>>>
69195>>>            
69195>>>        Loop
69196>>>>
69196>>>        
69196>>>        Writeln channel iChn
69198>>>        
69198>>>        // Struct
69198>>>        Writeln channel iChn "Struct " sPre sName
69203>>>        
69203>>>        For i from 0 to iLast
69209>>>>
69209>>>            Get MemberNameByIndex of hoJson i  to sMemb
69210>>>            Get MemberJsonType of hoJson sMemb to iType
69211>>>            
69211>>>            Write channel iChn (Repeat(" ", iInd))
69213>>>            
69213>>>            Case Begin
69213>>>                Case (iType = jsonTypeArray) 
69215>>>                    Get Member of hoJson sMemb to hoMemb
69216>>>                    
69216>>>                    If (MemberCount(hoMemb)) Begin
69218>>>                        Get MemberByIndex of hoMemb 0 to hoArrMemb
69219>>>                        Get JsonType of hoArrMemb to iArrType
69220>>>                        
69220>>>                        Case Begin
69220>>>                            Case (iArrType = jsonTypeBoolean)
69222>>>                                Write channel iChn "Boolean[]"
69224>>>                                Case Break
69225>>>                            Case (iArrType = jsonTypeDouble)
69228>>>                                Write channel iChn "Number[] "
69230>>>                                Case Break
69231>>>                            Case (iArrType = jsonTypeInteger)
69234>>>                                Write channel iChn "Integer[]"
69236>>>                                Case Break
69237>>>                            Case (iArrType = jsonTypeNull)
69240>>>                                Showln "***** WARNING: NULL ARRAY MEMBER FOUND *****"
69242>>>                                Showln "     Substituting string array instead,"
69244>>>                                Showln "     but this is probably incorrect"
69246>>>                                Set piWarnings to (piWarnings(Self) + 1)
69247>>>                                Writeln channel iChn "// ToDo: String substituted for null member in sample JSON"
69250>>>                                Write channel iChn (Repeat(" ", iInd)) "String[] "
69253>>>                                Case Break
69254>>>                            Case (iArrType = jsonTypeObject)
69257>>>                                Write channel iChn sPre (UCFirst(Self, sMemb)) "[]"
69261>>>                                Case Break
69262>>>                            Case (iArrType = jsonTypeString)
69265>>>                                Write channel iChn "String[] "
69267>>>                                Case Break
69268>>>                            Case (iArrType = jsonTypeArray)
69271>>>                                Showln "***** WARNING: MULTI-DIMENSIONAL ARRAY *****"
69273>>>                                Showln "     Cannot process - defaulting '" sMemb "' to string[], which IS WRONG!"
69277>>>                                Set piWarnings to (piWarnings(Self) + 1)
69278>>>                                Writeln "// ToDo: Myulti dimentional array in sample JSON - String[] used instead"
69280>>>                                Write channel iChn "String[] "
69282>>>                                Case Break
69283>>>                        Case End
69283>>>
69283>>>                        Send Destroy of hoArrMemb
69284>>>                    End
69284>>>>
69284>>>                    Else Begin
69285>>>                        Showln "***** WARNING: EMPTY ARRAY *****"
69287>>>                        ShowLn '     Cannot determine member type for array "' sMemb '"'
69291>>>                        Showln '     Defaulting type to string, which is probably wrong (it may be a complex type)'
69293>>>                        Showln '     Suggest you populate the FIRST member of the "' sMemb '" array'
69297>>>                        Showln '     with one filled-out item in the JSON window and regenerate'
69299>>>                        Set piWarnings to (piWarnings(Self) + 1)
69300>>>                        Writeln "// ToDo: Sample JSON had empty array, so used array of String instead, which may not be correct"
69302>>>                        Write channel iChn (Repeat(" ", iInd)) "String[] "
69305>>>                    End
69305>>>>
69305>>>                    
69305>>>                    Send Destroy of hoMemb
69306>>>                    Case Break
69307>>>                Case (iType = jsonTypeBoolean)
69310>>>                    Write channel iChn "Boolean "
69312>>>                    Case Break
69313>>>                Case (iType = jsonTypeDouble)
69316>>>                    Write channel iChn "Number  "
69318>>>                    Case Break
69319>>>                Case (iType = jsonTypeInteger)
69322>>>                    Write channel iChn "Integer "
69324>>>                    Case Break
69325>>>                Case (iType = jsonTypeString)
69328>>>                    Write channel iChn "String  "
69330>>>                    Case Break
69331>>>                Case (iType = jsonTypeNull)
69334>>>                    Showln "***** WARNING: NULL JSON MEMBER FOUND *****"
69336>>>                    Showln "     Substituting string instead,"
69338>>>                    Showln "     but this is probably incorrect"
69340>>>                    Set piWarnings to (piWarnings(Self) + 1)
69341>>>                    Writeln channel iChn "// ToDo: Substituted String for null member in sample JSON"
69344>>>                    Write (Repeat(" ", iInd)) "String  "
69346>>>                    Case Break
69347>>>                Case (iType = jsonTypeObject)
69350>>>                    Write channel iChn sPre  (UCFirst(Self, sMemb))
69353>>>            Case End
69353>>>            
69353>>>            Writeln channel iChn " " sMemb
69357>>>        Loop        
69358>>>>
69358>>>        
69358>>>        Writeln channel iChn "End_Struct"
69361>>>        Writeln channel iChn
69363>>>        
69363>>>        Close_Output channel iChn
69365>>>        Send Seq_Release_Channel iChn
69366>>>    End_Procedure
69367>>>
69367>>>    Procedure Generate
69370>>>        String   sSource sPath sName sIPre sErr sPartPath sRPath
69370>>>        String[] asDirs asEmpty asOrig asRepl
69374>>>        Boolean  bOK bExist
69374>>>        Integer  i iWarns iType iLast iInd iChn
69374>>>        Handle   hoJson      
69374>>>        
69374>>>        Get Value of oJsonText to sSource
69375>>>        
69375>>>        If (sSource = "") Begin
69377>>>            Send UserError "You need to paste sample JSON into the window before attempting to generate struct(s) from it" "No JSON"
69378>>>            Procedure_Return
69379>>>        End
69379>>>>
69379>>>        
69379>>>        If (Value(oOuterName(Self)) = "") Begin
69381>>>            Send UserError "You must specify a name for the outer struct" "No Name specified"
69382>>>            Procedure_Return
69383>>>        End
69383>>>>
69383>>>        
69383>>>        If (Value(oOutput(Self)) = "") Begin
69385>>>            Send UserError "You must specify a path to write the packages to" "No Path specified"
69386>>>            Procedure_Return
69387>>>        End
69387>>>>
69387>>>        
69387>>>        Set pasOriginalNames to asEmpty
69388>>>        Set pasReplacedNames to asEmpty
69389>>>        
69389>>>        Get Value of oOutput    to sPath
69390>>>        Set psPath              to sPath
69391>>>        Get Value of oRelPath   to sRPath
69392>>>        Set psAppPath           to sRpath
69393>>>        Get Value of oOuterName to sName
69394>>>        Set psOuter             to sName
69395>>>        Get Value of oIndent    to iInd
69396>>>        Set piIndent            to iInd
69397>>>
69397>>>        Set piWarnings          to 0
69398>>>
69398>>>        Get Create (RefClass(cJsonObject)) to hoJson
69399>>>        
69399>>>        Get ParseString of hoJson sSource to bOK
69400>>>        
69400>>>        If not bOK Begin
69402>>>            Get psParseError of hoJson to sErr
69403>>>            Send UserError ("JSON" * sErr)
69404>>>            Send Destroy of hoJson
69405>>>            Procedure_Return
69406>>>        End
69406>>>>
69406>>>        
69406>>>        Get JsonType of hoJson to iType
69407>>>        
69407>>>        If (iType <> jsonTypeObject) Begin
69409>>>            Send UserError "Outer JSON not an object" "No JSON Object"
69410>>>            Send Destroy of hoJson
69411>>>            Procedure_Return
69412>>>        End
69412>>>>
69412>>>        
69412>>>        // Check if the output directory exists; if not create it
69412>>>        File_Exist sPath bExist
69413>>>
69413>>>        If not bExist Begin
69415>>>            Move (StrSplitToArray(sPath, "\"))  to asDirs
69416>>>            Move (SizeOfArray(asDirs) - 1)      to iLast
69417>>>            Move asDirs[0]                      to sPartPath
69418>>>            
69418>>>            For i from 1 to iLast
69424>>>>
69424>>>                File_Exist sPartPath bExist
69425>>>                
69425>>>                If not bExist Begin
69427>>>                    Make_Directory sPartPath
69428>>>                End
69428>>>>
69428>>>                
69428>>>                Move (sPartPath + "\" + asDirs[i]) to sPartPath
69429>>>            Loop
69430>>>>
69430>>>            
69430>>>            File_Exist sPartPath bExist
69431>>>            
69431>>>            If not bExist Begin
69433>>>                Make_Directory sPartPath
69434>>>            End
69434>>>>
69434>>>            
69434>>>        End
69434>>>>
69434>>>        
69434>>>        Send ReplaceNames hoJson
69435>>>        
69435>>>        Send WriteStruct hoJson "" ""
69436>>>        
69436>>>        Get pasOriginalNames    to asOrig
69437>>>        Get pasReplacedNames    to asRepl
69438>>>        Get Value of oOuterName to sName
69439>>>        Get Value of oIndent    to iInd
69440>>>
69440>>>        Get Seq_New_Channel to iChn
69441>>>        Append_Output channel iChn (psPath(Self) + "\" + sName + ".pkg")
69443>>>
69443>>>
69443>>>        Writeln channel iChn "Object oStructHandler_" sName " is a cObject"
69448>>>        WriteLn
69449>>>        Writeln (Repeat(" ", iInd)) "Procedure StructToJsonUChar " sName " stValue UChar[] ByRef ucaData"
69454>>>        Writeln (Repeat(" ", iInd * 2)) "Handle hoJson"
69457>>>        Writeln 
69458>>>        Writeln (Repeat(" ", iInd * 2)) "Get Create (RefClass(cJsonObject)) to hoJson"
69461>>>        Writeln (Repeat(" ", iInd * 2)) "Send DataTypeToJson of hoJson stValue"
69464>>>        Writeln (Repeat(" ", iInd * 2)) "Get StringifyUtf8 of hoJson to ucaData"
69467>>>        Writeln (Repeat(" ", iInd * 2)) "Send Destroy of hoJson"
69470>>>        Writeln (Repeat(" ", iInd)) "End_Procedure"
69473>>>        Writeln
69474>>>        Writeln (Repeat(" ", iInd )) "Procedure JsonUCharToStruct UChar[] ucaData " sName " ByRef stValue String ByRef sErr"
69479>>>        Writeln (Repeat(" ", iInd * 2)) "Handle hoJson"
69482>>>        Writeln (Repeat(" ", iInd * 2)) "Boolean bOK"
69485>>>        Writeln
69486>>>        Writeln (Repeat(" ", iInd * 2)) "Get Create (RefClass(cJsonObject)) to hoJson"
69489>>>        Writeln (Repeat(" ", iInd * 2)) "Set pbRequireAllMembers of hoJson to False"
69492>>>        Writeln (Repeat(" ", iInd * 2)) "Get ParseUtf8 of hoJson ucaData to bOK"
69495>>>        Writeln
69496>>>        Writeln (Repeat(" ", iInd * 2)) "If bOK ;"
69499>>>        Writeln (Repeat(" ", iInd * 3)) "Get JsonToDataType of hoJson to stValue"
69502>>>        Writeln (Repeat(" ", iInd * 2)) "Else ;"
69505>>>        Writeln (Repeat(" ", iInd * 3)) "Get psParseError of hoJson to sErr"
69508>>>        Writeln (Repeat(" ", iInd * 2)) ""
69511>>>        Writeln (Repeat(" ", iInd * 2)) "Send Destroy of hoJson"
69514>>>        Writeln (Repeat(" ", iInd)) "End_Procedure"
69517>>>        Writeln
69518>>>        Writeln channel iChn "End_Object"
69521>>>
69521>>>        Close_Output channel iChn
69523>>>        Send Seq_Release_Channel iChn
69524>>>
69524>>>        Send Destroy of hoJson
69525>>>        
69525>>>        Get piWarnings to iWarns
69526>>>        Showln "Struct and code generation for " sName " complete"
69530>>>        Showln "There " (If((iWarns = 1), "was ", "were ")) (String(iWarns)) " warning" (If((iWarns = 1), "", "s"))
69536>>>        
69536>>>        RunProgram Shell Background "explorer" sPath
69537>>>    End_Procedure
69538>>>
69538>>>    Object oJsonText is a cTextEdit
69540>>>        Set Size to 123 428
69541>>>        Set Location to 15 2
69542>>>        Set peAnchors to anAll
69543>>>        Set Label to "Paste sample JSON here:"
69544>>>        Set psToolTip to "Paste the JSON text on which to base your struct(s) here"
69545>>>        Set piMaxChars to 10000000
69546>>>    End_Object
69547>>>
69547>>>    Object oOuterName is a Form
69549>>>        Set Size to 13 256
69550>>>        Set Location to 142 102
69551>>>        Set peAnchors to anBottomLeft
69552>>>        Set Label_Col_Offset to 94
69553>>>        Set Label to "Outer struct name:"
69554>>>        Set Value to "t"
69555>>>        Set psToolTip to "Name for the outer struct from your JSON"
69556>>>    End_Object
69557>>>
69557>>>    Object oOutput is a Form
69559>>>        Set Size to 13 256
69560>>>        Set Location to 159 102
69561>>>        Set Label to "Path to write packages to:"
69562>>>        Set Label_Col_Offset to 94
69563>>>        Set peAnchors to anBottomLeftRight
69564>>>        Set psToolTip to "Path to create your struct packages at"
69565>>>        Set Prompt_Button_Mode to PB_PromptOn
69566>>>        
69566>>>        Procedure Activating
69569>>>            String  sPath iSep
69569>>>            Handle hoCL
69569>>>            Integer iLen i
69569>>>            
69569>>>            Forward Send Activating
69571>>>            
69571>>>            Get phoCommandLine of oApplication to hoCL
69572>>>            
69572>>>            If (hoCL and CountOfArgs(hoCL)) Begin
69574>>>                Get Argument of hoCL 1 to sPath
69575>>>                If (sPath = "") Break
69578>>>                
69578>>>                Move (Length(sPath)) to iLen
69579>>>                
69579>>>                For i from 0 to (iLen - 1)
69585>>>>
69585>>>                    If (Mid(sPath, 1, (iLen - i)) = "\") Move (iLen - i) to iSep
69588>>>                    If iSep Break
69591>>>                Loop
69592>>>>
69592>>>                
69592>>>                If iSep Begin
69594>>>                    Set Value to  (Left(sPath, iSep) + "AppSrc\ApiStructs")
69595>>>                End
69595>>>>
69595>>>                
69595>>>            End
69595>>>>
69595>>>            
69595>>>        End_Procedure
69596>>>        
69596>>>        Procedure Prompt
69599>>>            Boolean bOK
69599>>>            String  sPath sDir
69599>>>            Handle  hWnd
69599>>>            BrowseInfo tBI
69599>>>            BrowseInfo tBI
69599>>>            Integer iItem iOK i iLen
69599>>>
69599>>>            Get Window_Handle           to tBI.hwndOwner
69600>>>            Move "Select Output Folder" to tBI.lpszTitle
69601>>>            Move 0                      to tBI.pidlRoot
69602>>>            Move (BIF_NEWDIALOGSTYLE + BIF_UAHINT)   to tBI.ulFlags
69603>>>            
69603>>>            Move (SHBrowseForFolder(AddressOf(tBI))) to iItem
69604>>>            
69604>>>            If iItem Begin
69606>>>                ZeroString 512                                      to sPath
WARNING: 4532 Obsolete command: ZeroString. Use ZeroString(iLen) global function ON LINE: 561 (69606) OF FILE: C:\Projects\RESTGen191\AppSrc\Generator.vw
69607>>>                Move (SHGetPathFromIDList(iItem, AddressOf(sPath))) to iOK
69608>>>                Move (CString(sPath))                               to sPath
69609>>>                Set Value                                           to sPath
69610>>>                
69610>>>                Move (Length(sPath))    to iLen
69611>>>                Move ""                 to sDir
69612>>>                
69612>>>                For i from 0 to iLen
69618>>>>
69618>>>                    
69618>>>                    If (Mid(sPath, 1, (iLen - i)) = "\") Begin
69620>>>                        Move (Right(sPath, i)) to sDir
69621>>>                    End
69621>>>>
69621>>>                
69621>>>                    If (sDir <> "") Break
69624>>>                Loop
69625>>>>
69625>>>                
69625>>>            End
69625>>>>
69625>>>            
69625>>>            Set Value of oRelPath to sDir
69626>>>        End_Procedure
69627>>>        
69627>>>    End_Object
69628>>>
69628>>>    Object oRelPath is a Form
69630>>>        Set Size to 13 99
69631>>>        Set Location to 176 102
69632>>>        Set Label to "Struct path relative to AppSrc:"
69633>>>        Set Label_Col_Offset to 100
69634>>>        Set Value to "ApiStructs"
69635>>>        Set peAnchors to anBottomLeftRight
69636>>>        Set psToolTip to "Relative path from you AppSrc directory to your structs directory"
69637>>>    End_Object
69638>>>
69638>>>    Object oIndent is a SpinForm
69640>>>        Set Size to 13 28
69641>>>        Set Location to 158 402
69642>>>        Set Label to "Indent:"
69643>>>        Set Label_Col_Offset to 26
69644>>>        Set Spin_Value to 4
69645>>>        Set psToolTip to "Number of spaces to indent each source code level"
69646>>>        Set peAnchors to anBottomRight
69647>>>    End_Object
69648>>>
69648>>>    Object GenerateBtn is a Button
69650>>>        Set Size to 14 39
69651>>>        Set Location to 176 391
69652>>>        Set Label to "Generate"
69653>>>        Set peAnchors to anBottomRight
69654>>>        Set psToolTip to "Generate the struct packages"
69655>>>    
69655>>>        Procedure OnClick
69658>>>            Send Generate
69659>>>        End_Procedure
69660>>>    
69660>>>    End_Object
69661>>>CD_End_Object
69663>>>>
69663>
69663>        Procedure Activate_About
69666>            Send DoAbout "RESTGen JSON struct generator" "0.1.0" "Copyright (c) Unicorn InterGlobal Limited" "Unicorn InterGlobal Limited" "UnicornLogo.bmp"
69667>        End_Procedure
69668>
69668>    End_Object
69669>
69669>    Procedure AutoActivate
69672>        Handle hoMenu
69672>
69672>        // this activates all views from the view menu
69672>        Get phoViewMenu to hoMenu
69673>        If hoMenu Begin
69675>           Broadcast Send Execute of hoMenu
69677>        End
69677>
69677>        // this activates all views from the report view menu
69677>        Get phoReportMenu to hoMenu
69678>        If hoMenu Begin
69680>           Broadcast Send Execute of hoMenu
69682>        End
69682>    End_Procedure
69683>
69683>    Procedure MakeGoodPanelSize
69686>        Handle hoView hoClient
69686>        Integer iSize iLoc iHeight iWidth iOldHeight iOldWidth 
69686>        Integer iLeft iTop iRight iBottom
69686>        Get Client_Id to hoClient
69687>        If hoClient Begin
69689>            
69689>            // if not using commandbars or for some reason they are not created yet we
69689>            // will use whatever the client size is
69689>            If (ghoCommandBars=0 or not(IsComObjectCreated(ghoCommandBars))) Begin
69691>                Get GuiSize of hoClient to iSize  // starting size of client area
69692>                Move (Hi(iSize)) to iOldHeight
69693>                Move (Low(iSize)) to iOldWidth
69694>            End
69694>            Else Begin
69695>               // if commandbars are created, the actual size of the client area must be obtained
69695>               // from the commandbar 
69695>               Send ComGetClientRect of ghoCommandBars (&iLeft) (&iTop) (&iRight) (&iBottom)
69696>               Move (iRight-iLeft) to iOldWidth
69697>               Move (iBottom-iTop) to iOldHeight
69698>            End
69698>            
69698>            Move iOldHeight to iHeight
69699>            Move iOldWidth to iWidth
69700>            
69700>            // for each mdi client see if it fits, keep track of largest size needed
69700>            Get Next_Mdi_Dialog of hoClient True to hoView // find first
69701>            While (hoView)
69705>                Get GuiWindowSize of hoView to iSize    // size of view
69706>                Get GuiLocation of hoView to iLoc // location of view
69707>                Move (hi(iSize)+hi(iLoc)+10 max iHeight)  to iHeight // max height needed (+10 pixels is small border)
69708>                Move (low(iSize)+low(iLoc)+10 max iWidth) to iWidth  // max width needed
69709>                Get Next_Mdi_Dialog of hoClient False to hoView // find next view
69710>            Loop
69711>            Move (iHeight-iOldHeight  max 0) to iHeight // get delta compared to old size. We want delta
69712>            Move (iWidth-iOldWidth max 0) to iWidth     // only if the new size is bigger (i.e., > 0)
69713>            If  (iHeight>0 or iWidth>0) Begin
69715>                Get GuiSize to iSize // now add the delta to the panel size
69716>                Set GuiSize to (hi(iSize)+iHeight) (low(iSize)+iWidth)
69717>                Send Adjust_Logicals // adjust from gui to regular size
69718>            End
69718>        End
69718>    End_Procedure
69719>
69719>    // special test program  augmentation which opens all views and report views and
69719>    // makes sure that the size of the panel is big enough
69719>
69719>    Procedure End_Construct_Object
69722>        Boolean bAutoActivate
69722>        Get Auto_Activate_State to bAutoActivate
69723>        Forward Send End_Construct_Object
69725>        If bAutoActivate Begin
69727>            Send AutoActivate       // activate all views and report views
69728>            Send MakeGoodPanelSize  // make sure the panel is big enough for all of this
69729>        End
69729>    End_Procedure
69730>
69730>End_Object
69731>
69731>Start_UI
69732>
Summary
Memory Available: 1433559040
Total Warnings : 1
Total Errors   : 0
Total Symbols  : 40568
Total Resources: 0
Total Commands : 69731
Total Windows  : 0
Total Pages    : 0
Static Data    : 394907
Message area   : 490547
Total Blocks   : 25096
